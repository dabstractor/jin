name: "P1.M2.T1.S2 - Replace hardcoded iteration with dynamic ref listing in jin log"
description: |

---

## Goal

**Feature Goal**: Modify the `jin log` command to dynamically discover all layer refs using `repo.list_refs()` instead of iterating through hardcoded canonical paths, ensuring commits from non-canonical refs (e.g., ModeScope, ModeProject, ModeScopeProject) are displayed.

**Deliverable**: Updated `execute()` function in `src/commands/log.rs` that:
1. Calls `repo.list_refs("refs/jin/layers/**")` to get all layer refs
2. Parses each ref using `Layer::parse_layer_from_ref_path()` to determine layer type
3. Groups refs by Layer type in a `HashMap<Layer, Vec<String>>`
4. Iterates through `Layer::all_in_precedence_order()` and displays history for all refs of each layer type

**Success Definition**:
- Running `jin log` shows commits for ALL layer refs, not just canonical paths
- Commits to ModeScope layers (`refs/jin/layers/mode/<mode>/scope/<scope>/_`) are displayed
- Commits to ModeProject layers (`refs/jin/layers/mode/<mode>/project/<project>`) are displayed
- Commits to ModeScopeProject layers (`refs/jin/layers/mode/<mode>/scope/<scope>/project/<project>`) are displayed
- The existing `show_layer_history()` function is preserved and reused
- Precedence order display is maintained

## User Persona

**Target User**: Jin CLI developers and users debugging layer configuration changes

**Use Case**: When users create scopes under modes, or create project-specific mode configs, they need to see the commit history for those layers to debug configuration issues and track changes.

**User Journey**:
1. User creates a mode: `jin mode create development`
2. User creates a scope under that mode: `jin scope create api --mode development`
3. User commits changes to the ModeScope layer
4. User runs `jin log` to see commit history
5. **Current behavior**: ModeScope commits are NOT shown (BUG)
6. **Expected behavior**: All layer commits are shown in precedence order

**Pain Points Addressed**:
- Cannot debug configuration issues for non-canonical layer refs
- Missing audit trail for ModeScope, ModeProject, ModeScopeProject commits
- PRD compliance issue - §18.6 requires showing history for all layers

## Why

- **Business value**: Users need full visibility into layer commit history for debugging and auditing
- **Integration with existing features**: S1 implemented `parse_layer_from_ref_path()` which S2 depends on
- **Problems this solves**:
  - Current implementation only checks canonical paths generated by `layer.ref_path()`
  - ModeScope refs like `refs/jin/layers/mode/dev/scope/api/_` are missed
  - This is Major Bug #2 from the bug report

## What

Modify the `execute()` function in `src/commands/log.rs` to replace the hardcoded iteration through `Layer::all_in_precedence_order()` with dynamic ref discovery.

### Success Criteria

- [ ] `jin log` discovers all layer refs dynamically using `repo.list_refs("refs/jin/layers/**")`
- [ ] Discovered refs are parsed and grouped by layer type using `Layer::parse_layer_from_ref_path()`
- [ ] History is displayed for all refs of each layer type, not just the canonical ref
- [ ] Precedence order is maintained (layers still displayed in order 1-9)
- [ ] Existing `show_layer_history()` function is reused without modification
- [ ] Context filtering (mode/scope requirements) is preserved

## All Needed Context

### Context Completeness Check

**"No Prior Knowledge" test validation**: If someone knew nothing about this codebase, would they have everything needed to implement this successfully?

**YES** - This PRP provides:
- Complete current implementation of `src/commands/log.rs`
- Complete `parse_layer_from_ref_path()` function from S1
- Complete `repo.list_refs()` function signature and usage
- Complete Layer enum with all variants and precedence order
- Exact line numbers and code patterns to follow
- Validation commands specific to this codebase

### Documentation & References

```yaml
# MUST READ - Include these in your context window
- file: src/commands/log.rs
  why: This is the file to modify. Contains current execute() and show_layer_history() implementations.
  pattern: The for loop at lines 38-63 that iterates through all_layers needs to be replaced.
  critical: The show_layer_history() function (lines 74-138) must be preserved and reused.

- file: src/core/layer.rs:183-222
  why: Contains parse_layer_from_ref_path() implementation from S1.
  pattern: Returns Option<Layer> - Some(Layer) if ref matches a layer pattern, None otherwise.
  critical: Handles the /_ suffix correctly for ModeBase and ModeScope layers.

- file: src/git/refs.rs
  why: Contains list_refs() function for discovering all layer refs.
  pattern: fn list_refs(&self, pattern: &str) -> Result<Vec<String>>
  gotcha: Use "refs/jin/layers/**" pattern with double asterisk for recursive match.

- docfile: plan/001_8630d8d70301/bug_hunt_tasks.json
  why: Contains the complete contract definition for P1.M2.T1.S2 with dependencies on S1.
  section: P1.M2.T1.S2 (lines 113-123)

- docfile: plan/001_8630d8d70301/bugfix/001_d2716c9eb3cf/P1M2T1S2/PRP.md
  why: This PRP document - contains all context needed for implementation.
```

### Current Codebase Tree (relevant portions)

```bash
src/
├── commands/
│   ├── log.rs          # TARGET FILE - Modify execute() function here
│   ├── mode.rs         # Example of list_refs() usage pattern
│   ├── push.rs         # Example of list_refs() usage pattern
│   └── ...
├── core/
│   ├── layer.rs        # Contains Layer enum and parse_layer_from_ref_path()
│   ├── mod.rs          # Exports Layer, JinError, Result, ProjectContext
│   └── ...
├── git/
│   ├── refs.rs         # Contains RefOps trait with list_refs() method
│   ├── repo.rs         # JinRepo struct with inner() method
│   └── ...
├── cli/
│   └── args.rs         # Contains LogArgs struct
└── test_utils.rs       # Contains test utilities
```

### Desired Codebase Tree with Files to be Modified

```bash
src/
├── commands/
│   └── log.rs          # MODIFY: Replace lines 38-63 in execute() function
│                       # CHANGE: Use HashMap<Layer, Vec<String>> for grouping refs
│                       # PRESERVE: show_layer_history() function unchanged
```

### Known Gotchas of Our Codebase & Library Quirks

```rust
// CRITICAL: parse_layer_from_ref_path() is on the Layer enum itself
// Use: Layer::parse_layer_from_ref_path(&ref_path) - NOT as a method on instance
// Returns: Option<Layer> - need to handle None case (filter out non-layer refs)

// CRITICAL: list_refs() uses glob patterns - double asterisk for recursive match
// Use: "refs/jin/layers/**" to get all refs recursively
// NOT: "refs/jin/layers/*" which only gets direct children

// CRITICAL: The /_ suffix is a LITERAL STRING, not a wildcard
// ModeBase ref path: "refs/jin/layers/mode/<name>/_"
// ModeScope ref path: "refs/jin/layers/mode/<mode>/scope/<scope>/_"
// parse_layer_from_ref_path() handles this correctly

// CRITICAL: show_layer_history() takes a specific ref_path parameter
// Current signature: show_layer_history(repo, layer, context, count)
// Internally it calls layer.ref_path() - need to refactor or iterate refs
// SIMPLER: Call show_layer_history() once per ref with ref_path override

// CRITICAL: Layer::all_in_precedence_order() returns Vec<Layer> in precedence order 1-9
// Must iterate in this order for display consistency
// 1=GlobalBase, 2=ModeBase, 3=ModeScope, 4=ModeScopeProject, 5=ModeProject, ...

// CRITICAL: Context filtering must be preserved
// if layer.requires_mode() && context.mode.is_none() { continue; }
// if layer.requires_scope() && context.scope.is_none() { continue; }

// CRITICAL: JinError is the error type used throughout
// All functions return Result<T> which is Result<T, JinError>
// Use ? operator for error propagation

// CRITICAL: repo.list_refs() is on the JinRepo struct
// Access via: repo.list_refs("refs/jin/layers/**")?
// Returns: Result<Vec<String>> with full ref paths like "refs/jin/layers/global"
```

## Implementation Blueprint

### Data Models and Structure

No new data models needed. Use existing types:
- `Layer` enum from `src/core/layer.rs`
- `HashMap<Layer, Vec<String>>` for grouping refs by layer type
- `Result<T>` = `Result<T, JinError>` for error handling

### Implementation Tasks (ordered by dependencies)

```yaml
Task 1: UNDERSTAND current implementation (READ ONLY)
  - READ: src/commands/log.rs lines 14-71 (execute function)
  - READ: src/commands/log.rs lines 74-138 (show_layer_history function)
  - UNDERSTAND: Current loop at lines 38-63 iterates Layer::all_in_precedence_order()
  - UNDERSTAND: Current code calls layer.ref_path() to get canonical path
  - UNDERSTAND: Current code checks if ref exists with git_repo.find_reference()
  - IDENTIFY: The for loop to replace (lines 38-63)

Task 2: REFACTOR show_layer_history() to accept ref_path parameter (OPTIONAL)
  - ALTERNATIVE: Keep show_layer_history() as-is and call it multiple times
  - DECISION: Either refactor show_layer_history() or iterate refs in execute()
  - SIMPLER APPROACH: Keep show_layer_history() unchanged, iterate refs in execute()

Task 3: MODIFY execute() function - Dynamic ref discovery
  - PRESERVE: Lines 15-26 (context loading and repo opening)
  - PRESERVE: Lines 29-32 (specific layer case - keep as-is)
  - REPLACE: Lines 34-67 (the for loop over all_layers)
  - IMPLEMENT:
    1. Call repo.list_refs("refs/jin/layers/**")? to get all refs
    2. Create HashMap<Layer, Vec<String>> to group refs by layer
    3. For each ref in list_refs result:
       - Call Layer::parse_layer_from_ref_path(&ref_path)
       - If Some(layer), insert into HashMap: layer_refs.entry(layer).or_default().push(ref_path)
    4. Iterate Layer::all_in_precedence_order() for display order
    5. For each layer in precedence order:
       - Check context requirements (requires_mode, requires_scope)
       - Get refs from HashMap for this layer
       - For each ref, call show_layer_history() with the specific ref_path

Task 4: PRESERVE existing error handling and edge cases
  - PRESERVE: "No commits found in any layer" message when HashMap is empty
  - PRESERVE: Layer separator (println!("=== {} ===", layer))
  - PRESERVE: Shown_any flag for proper spacing
  - PRESERVE: Context filtering (mode/scope requirements)

Task 5: VERIFY imports and dependencies
  - ADD: use std::collections::HashMap;
  - VERIFY: use crate::core::{JinError, Layer, ProjectContext, Result};
  - VERIFY: use crate::git::JinRepo;
  - VERIFY: Layer::parse_layer_from_ref_path is accessible (should be via impl Layer)

Task 6: RUN existing tests to ensure no regression
  - RUN: cargo test --test log
  - VERIFY: test_parse_layer_name still passes
  - VERIFY: test_execute_not_initialized still passes
  - VERIFY: test_count_files_empty_commit still passes
```

### Implementation Patterns & Key Details

```rust
// Current implementation pattern (lines 38-63) - TO BE REPLACED:
let all_layers = Layer::all_in_precedence_order();
let mut shown_any = false;

for layer in &all_layers {
    // Skip layers that don't apply to current context
    if layer.requires_mode() && context.mode.is_none() {
        continue;
    }
    if layer.requires_scope() && context.scope.is_none() {
        continue;
    }

    let ref_path = layer.ref_path(
        context.mode.as_deref(),
        context.scope.as_deref(),
        context.project.as_deref(),
    );

    // Check if ref exists
    if git_repo.find_reference(&ref_path).is_ok() {
        if shown_any {
            println!();
        }
        println!("=== {} ===", layer);
        println!();
        show_layer_history(git_repo, *layer, &context, args.count)?;
        shown_any = true;
    }
}

// NEW implementation pattern to replace above:
use std::collections::HashMap;

// Discover all layer refs dynamically
let all_refs = repo.list_refs("refs/jin/layers/**")?;

// Group refs by layer type
let mut layer_refs: HashMap<Layer, Vec<String>> = HashMap::new();
for ref_path in all_refs {
    if let Some(layer) = Layer::parse_layer_from_ref_path(&ref_path) {
        layer_refs.entry(layer).or_default().push(ref_path);
    }
}

// Display in precedence order
let all_layers = Layer::all_in_precedence_order();
let mut shown_any = false;

for layer in &all_layers {
    // Skip layers that don't apply to current context
    if layer.requires_mode() && context.mode.is_none() {
        continue;
    }
    if layer.requires_scope() && context.scope.is_none() {
        continue;
    }

    // Get all refs for this layer type
    if let Some(refs) = layer_refs.get(layer) {
        for ref_path in refs {
            if shown_any {
                println!();
            }
            println!("=== {} ({}) ===", layer, ref_path);
            println!();
            show_layer_history_for_ref(git_repo, ref_path, *layer, args.count)?;
            shown_any = true;
        }
    }
}

// NOTE: show_layer_history() currently calls layer.ref_path() internally
// Need to either:
// OPTION A: Refactor show_layer_history() to accept ref_path parameter
// OPTION B: Create a helper function show_layer_history_for_ref()
//           that takes ref_path directly instead of calling layer.ref_path()

// PATTERN from src/commands/push.rs line 115:
let all_refs = jin_repo.list_refs("refs/jin/layers/*")?;

// PATTERN from src/commands/mode.rs line 182:
let mode_refs = repo.list_refs("refs/jin/modes/*/_mode")?;

// PATTERN for HashMap entry initialization:
layer_refs.entry(layer).or_insert_with(Vec::new).push(ref_path);
// OR
layer_refs.entry(layer).or_default().push(ref_path);

// CRITICAL: Layer::parse_layer_from_ref_path() signature
pub fn parse_layer_from_ref_path(ref_path: &str) -> Option<Layer>
// Called as: Layer::parse_layer_from_ref_path(&ref_path)
// Returns: Some(Layer) if matches pattern, None otherwise

// CRITICAL: list_refs() signature
fn list_refs(&self, pattern: &str) -> Result<Vec<String>>
// Called on: &JinRepo (via the RefOps trait)
// Returns: Vec<String> of full ref paths like "refs/jin/layers/global"
```

### Integration Points

```yaml
MODIFY: src/commands/log.rs
  - function: execute() (lines 14-71)
  - modify: lines 34-67 (the for loop over all_layers)
  - add: use std::collections::HashMap; at top of file
  - preserve: show_layer_history() function (may need slight refactor)

PRESERVE: src/core/layer.rs
  - function: parse_layer_from_ref_path() (lines 183-222)
  - function: all_in_precedence_order() (returns Vec<Layer>)

PRESERVE: src/git/refs.rs
  - function: list_refs() (already exists, no modification needed)

PRESERVE: tests/
  - existing tests should continue to pass
  - S3 will add new integration test
```

## Validation Loop

### Level 1: Syntax & Style (Immediate Feedback)

```bash
# Run after modifying src/commands/log.rs
cargo check --bin jin 2>&1

# Expected: No compilation errors. If errors exist:
# - Check imports (use std::collections::HashMap;)
# - Check function signatures (list_refs, parse_layer_from_ref_path)
# - Check Option handling (if let Some(layer) = ...)
# - Check Result propagation (? operator usage)

# Format check
cargo fmt --check 2>&1

# Clippy linting
cargo clippy --bin jin 2>&1

# Expected: Zero errors. Fix any warnings before proceeding.
```

### Level 2: Unit Tests (Component Validation)

```bash
# Test the log command module
cargo test --lib commands::log::tests 2>&1

# Expected output:
# test test_parse_layer_name ... ok
# test test_execute_not_initialized ... ok
# test test_count_files_empty_commit ... ok

# Test parse_layer_from_ref_path (from S1)
cargo test --lib core::layer::tests::test_parse_layer_from_ref_path 2>&1

# Expected: All tests pass, confirming parse function works

# Full lib tests
cargo test --lib 2>&1

# Expected: All tests pass. If failures occur, check:
# - Did you accidentally modify show_layer_history()?
# - Are imports correct?
# - Is HashMap usage correct?
```

### Level 3: Manual Testing (System Validation)

```bash
# Setup: Create a test environment
cd /tmp/jin_test && rm -rf .jin && jin init

# Create a mode
jin mode create testmode

# Create a scope under the mode (this creates ModeBase AND ModeScope refs)
jin scope create testscope --mode testmode

# Make some config changes
echo '{"mode": "test"}' > config.json
jin add config.json --mode
jin commit -m "Add mode config"

# Make more changes to ModeScope
echo '{"scope": "test"}' > scope.json
jin add scope.json
jin commit -m "Add scope config"

# Run jin log - should show BOTH commits
jin log 2>&1 | tee log_output.txt

# Expected output should include:
# === ModeBase ===
# commit <hash> (mode-base)
# ...
# Add mode config
#
# === ModeScope ===
# commit <hash> (mode-scope)
# ...
# Add scope config

# CLEANUP
cd /tmp && rm -rf jin_test
```

### Level 4: Git Reference Verification

```bash
# Verify refs were created correctly
cd /tmp/jin_test
git show-ref | grep jin/layers

# Expected output:
# <hash> refs/jin/layers/mode/testmode/_
# <hash> refs/jin/layers/mode/testmode/scope/testscope/_

# Verify both refs are found by list_refs pattern
git for-each-ref 'refs/jin/layers/**'

# Expected: Both refs listed
# <hash> commit		refs/jin/layers/mode/testmode/_
# <hash> commit		refs/jin/layers/mode/testmode/scope/testscope/_
```

## Final Validation Checklist

### Technical Validation

- [ ] Code compiles without errors: `cargo check --bin jin`
- [ ] All existing unit tests pass: `cargo test --lib commands::log::tests`
- [ ] parse_layer_from_ref_path tests pass: `cargo test --lib core::layer::tests::test_parse_layer_from_ref_path`
- [ ] Code follows existing patterns in log.rs
- [ ] HashMap import added: `use std::collections::HashMap;`
- [ ] No clippy warnings: `cargo clippy --bin jin`

### Feature Validation

- [ ] `jin log` discovers all layer refs dynamically
- [ ] ModeBase commits are displayed (refs/jin/layers/mode/<name>/_)
- [ ] ModeScope commits are displayed (refs/jin/layers/mode/<mode>/scope/<scope>/_)
- [ ] ModeProject commits are displayed (refs/jin/layers/mode/<mode>/project/<project>)
- [ ] ModeScopeProject commits are displayed (refs/jin/layers/mode/<mode>/scope/<scope>/project/<project>)
- [ ] Precedence order is maintained (1-9 display order)
- [ ] Context filtering preserved (mode/scope requirements)
- [ ] "No commits found" message works when no refs exist

### Code Quality Validation

- [ ] show_layer_history() function preserved (not deleted or heavily modified)
- [ ] Error handling follows existing patterns (Result<?>, ? operator)
- [ ] Line spacing and formatting matches codebase style
- [ ] Comments added for complex logic (HashMap grouping, ref parsing)
- [ ] No dead code or unused imports

### Documentation & Deployment

- [ ] Code is self-documenting with clear variable names
- [ ] Function purpose is clear from implementation
- [ ] Ready for S3 integration test to verify end-to-end

---

## Anti-Patterns to Avoid

- ❌ Don't modify `show_layer_history()` to take `ref_path` parameter unless necessary - simpler to iterate refs in `execute()`
- ❌ Don't use `"refs/jin/layers/*"` (single asterisk) - use `"refs/jin/layers/**"` (double asterisk) for recursive match
- ❌ Don't forget to handle `None` from `parse_layer_from_ref_path()` - filter out non-matching refs
- ❌ Don't break the precedence order - must iterate `Layer::all_in_precedence_order()` for display
- ❌ Don't remove context filtering (mode/scope requirements) - must be preserved
- ❌ Don't hardcode layer names or ref paths - use dynamic discovery
- ❌ Don't use `unwrap()` on `list_refs()` result - use `?` operator for proper error propagation
- ❌ Don't forget to add `use std::collections::HashMap;` import at top of file
- ❌ Don't create a new helper function if the logic fits in `execute()` - keep it simple
- ❌ Don't modify the `parse_layer_from_ref_path()` function - it's from S1 and should be used as-is

---

## Confidence Score: 9/10

**Reasoning**:
- All dependencies (S1 parse_layer_from_ref_path) are complete and available
- All required functions (list_refs, Layer enum) are well-documented
- Current implementation is thoroughly understood
- Clear path to implementation with minimal risk
- One point deducted due to potential need to slightly refactor show_layer_history() or create a helper for ref-based history display

**Validation**: The PRP provides complete context for one-pass implementation success including exact line numbers, complete function implementations, and specific validation commands.
