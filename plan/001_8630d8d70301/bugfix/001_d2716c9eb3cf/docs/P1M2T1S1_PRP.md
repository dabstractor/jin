name: "PRP for P1.M2.T1.S1: Add parse_layer_from_ref_path() helper function"
description: |

---

## Goal

**Feature Goal**: Create a helper function `parse_layer_from_ref_path()` that parses a Git ref path string and returns the corresponding `Layer` enum variant, enabling dynamic layer discovery for the `jin log` command.

**Deliverable**: A new pure function `parse_layer_from_ref_path(ref_path: &str) -> Option<Layer>` in `src/core/layer.rs` that:
- Parses all 9 layer types from their ref path patterns
- Handles the `/_` suffix correctly for parent layers
- Returns `None` for invalid or unrecognized ref paths
- Includes comprehensive unit tests

**Success Definition**:
- Function correctly identifies all 9 layer types from their canonical ref paths
- All existing unit tests pass: `cargo test --lib layer`
- New unit tests cover all layer types and edge cases
- Function returns `Option<Layer>` (not `Result`) per codebase convention
- Zero clippy warnings: `cargo clippy --all-targets`

## User Persona (if applicable)

**Target User**: Internal - `jin log` command implementation

**Use Case**: The `jin log` command needs to dynamically discover which layers have commits by listing all refs under `refs/jin/layers/**` and parsing each ref path to determine its layer type.

**User Journey**:
1. Log command calls `git_repo.references_glob("refs/jin/layers/**")` to get all layer refs
2. For each ref path, calls `parse_layer_from_ref_path(ref_path)` to identify layer type
3. Groups refs by layer type and displays commit history in precedence order

**Pain Points Addressed**:
- Current log command uses `Layer::all_in_precedence_order()` with canonical ref paths only
- Misses refs created with non-canonical naming patterns
- Cannot display commits from layers that weren't iterated in the hardcoded list

## Why

- **Bug Fix**: Resolves the issue where `jin log` misses commits from layers like ModeScope because it only checks canonical paths generated by `layer.ref_path()`
- **Enables Dynamic Discovery**: This function is the foundation for P1.M2.T1.S2 which will replace hardcoded iteration with dynamic ref discovery
- **PRD Compliance**: Required for PRD §18.6: "`jin log [layer]` - Show commit history for layer"
- **Test Infrastructure**: Provides testable unit for layer path parsing

## What

Add a new helper function to `src/core/layer.rs` that parses ref path strings and returns the corresponding `Layer` variant.

### Function Signature

```rust
impl Layer {
    /// Parse a layer from a Git ref path.
    ///
    /// Returns `Some(Layer)` if the ref path matches a known layer pattern,
    /// or `None` if the path is invalid or doesn't match any layer.
    ///
    /// # Examples
    ///
    /// ```ignore
    /// assert_eq!(parse_layer_from_ref_path("refs/jin/layers/global"), Some(Layer::GlobalBase));
    /// assert_eq!(parse_layer_from_ref_path("refs/jin/layers/mode/development/_"), Some(Layer::ModeBase));
    /// assert_eq!(parse_layer_from_ref_path("refs/jin/layers/mode/production/scope/api/_"), Some(Layer::ModeScope));
    /// assert_eq!(parse_layer_from_ref_path("invalid/path"), None);
    /// ```
    pub fn parse_layer_from_ref_path(ref_path: &str) -> Option<Layer> {
        // Implementation
    }
}
```

### Ref Path Patterns to Match

| Layer Variant | Ref Path Pattern | Example | Notes |
|---------------|------------------|---------|-------|
| `GlobalBase` | `refs/jin/layers/global` | `refs/jin/layers/global` | Simple path |
| `ModeBase` | `refs/jin/layers/mode/<name>/_` | `refs/jin/layers/mode/claude/_` | Requires `/_` suffix |
| `ModeScope` | `refs/jin/layers/mode/<mode>/scope/<scope>/_` | `refs/jin/layers/mode/dev/scope/api/_` | Requires `/_` suffix |
| `ModeScopeProject` | `refs/jin/layers/mode/<mode>/scope/<scope>/project/<project>` | `refs/jin/layers/mode/dev/scope/api/project/ui` | No `/_` suffix |
| `ModeProject` | `refs/jin/layers/mode/<mode>/project/<project>` | `refs/jin/layers/mode/dev/project/backend` | No `/_` suffix |
| `ScopeBase` | `refs/jin/layers/scope/<name>` | `refs/jin/layers/scope/config` | Simple path |
| `ProjectBase` | `refs/jin/layers/project/<name>` | `refs/jin/layers/project/api-server` | Simple path |
| `UserLocal` | `refs/jin/layers/local` | `refs/jin/layers/local` | Simple path |
| `WorkspaceActive` | `refs/jin/layers/workspace` | `refs/jin/layers/workspace` | Simple path |

### Success Criteria

- [ ] Function correctly parses all 9 layer types from their canonical ref paths
- [ ] Function returns `None` for invalid paths (wrong prefix, malformed, unknown patterns)
- [ ] All existing tests in `src/core/layer.rs` pass
- [ ] New unit tests cover each layer type with valid paths
- [ ] New unit tests cover edge cases (empty string, wrong prefix, partial paths)
- [ ] No clippy warnings: `cargo clippy --all-targets`

## All Needed Context

### Context Completeness Check

**Validation**: "If someone knew nothing about this codebase, would they have everything needed to implement this successfully?"

**Yes** - This PRP provides:
- Complete Layer enum reference with all 9 variants
- Exact ref path patterns from existing `Layer::ref_path()` method
- Similar parsing pattern from `src/commands/list.rs`
- Test patterns from existing unit tests
- Rust parsing best practices with code examples
- Validation commands specific to this codebase

### Documentation & References

```yaml
# MUST READ - Layer enum and ref_path method
- file: src/core/layer.rs
  why: Contains Layer enum definition and ref_path() method that generates canonical paths
  pattern: Read lines 10-31 for Layer enum variants, lines 57-96 for ref_path() method
  gotcha: Note the `/_` suffix on ModeBase, ModeScope - these layers can have child refs

# MUST READ - Similar parsing pattern in codebase
- file: src/commands/list.rs
  why: Shows existing path parsing pattern using split() and slice pattern matching
  pattern: Lines 110-162 (parse_ref_path function) - split on '/', collect Vec, match on slice
  critical: Uses `parts.as_slice()` with slice patterns like ["mode", mode], ["mode", mode, "scope", scope]

# MUST READ - Test patterns for Option return values
- file: src/commands/list.rs
  why: Shows how to test functions that return Option/Result
  pattern: Lines 229-368 - unit tests for parse_ref_path, parse_mode_ref, parse_scope_ref
  critical: Uses `assert!(result.is_some())`, `assert!(result.is_none())`, `unwrap()` for value extraction

# MUST READ - Existing layer tests
- file: src/core/layer.rs
  why: Shows test structure and patterns used in this module
  pattern: Lines 188-295 - existing tests for precedence, ref_paths, storage_paths
  critical: Tests are in `#[cfg(test)] mod tests` block within the same file

# RESEARCH - Rust parsing best practices
- docfile: plan/001_8630d8d70301/bugfix/001_d2716c9eb3cf/P1M2T1S1/research/rust_parsing_research.md
  why: Complete guide on Option<T> parsing, split() patterns, suffix handling, testing
  section: Sections 1-3 cover parsing patterns, Section 5 covers testing patterns

# EXTERNAL - Rust Option documentation
- url: https://doc.rust-lang.org/std/option/enum.Option.html
  why: Official documentation on Option methods and combinators
  critical: Methods: map, and_then, filter, ok_or, unwrap, unwrap_or

# EXTERNAL - Rust pattern matching
- url: https://doc.rust-lang.org/book/ch06-02-match.html
  why: Pattern matching on slices for path segment matching
  critical: Slice patterns like ["prefix", rest @ ..], @ patterns for capturing

# EXTERNAL - Rust string methods
- url: https://doc.rust-lang.org/std/primitive.str.html#method.split
  why: split() returns an iterator, use .collect() to get Vec<&str>
  critical: Combine with .filter() to handle empty segments from paths like "a//b"

# REFERENCE - Git refs operations
- file: src/git/refs.rs
  why: Shows list_refs() pattern that will be used in P1.M2.T1.S2
  pattern: Lines 109-121 - references_glob() usage for discovering refs
```

### Current Codebase Tree (relevant sections)

```bash
src/
├── core/
│   ├── mod.rs           # Module exports
│   ├── layer.rs         # TARGET FILE - Add function here (after line 169, before tests)
│   └── error.rs         # JinError types (if Result needed instead of Option)
├── commands/
│   ├── log.rs           # Will use this function in P1.M2.T1.S2
│   └── list.rs          # Reference for similar parsing pattern
└── test_utils.rs        # Test setup patterns
```

### Desired Codebase Tree with Files to be Added

```bash
src/
├── core/
│   ├── layer.rs         # MODIFIED: Add parse_layer_from_ref_path() method
│   └── (no new files - function is an impl method on Layer)
```

### Known Gotchas of Our Codebase & Library Quirks

```rust
// CRITICAL: The /_ suffix is IMPORTANT
// ModeBase and ModeScope use /_ suffix because they can have child refs
// This avoids Git ref naming conflicts - a ref can't exist at a path that has children
// Example: refs/jin/layers/mode/claude can't exist if refs/jin/layers/mode/claude/project/ exists
// The /_ suffix solves this: refs/jin/layers/mode/claude/_ can coexist with child refs

// CRITICAL: Parse ONLY from canonical ref paths
// The Layer enum doesn't store mode/scope/project names
// So parse_layer_from_ref_path() only determines layer TYPE, not specific context
// Context (mode name, scope name, etc.) is handled by the caller

// CRITICAL: Use Option<Layer> not Result<Layer, E>
// Absence of a match is expected, not an error
// This follows the pattern in src/commands/list.rs::parse_ref_path()

// CRITICAL: Slice pattern matching syntax
// Use parts.as_slice() and match on slice patterns:
// ["global"] => single segment
// ["mode", mode, "_"] => three segments, capture middle
// ["mode", mode, "scope", scope, "_"] => five segments, capture two middle
// Note: "_" in slice pattern is a literal underscore, not a wildcard

// CRITICAL: Path prefix validation
// Check ref_path.starts_with("refs/jin/layers/") first
// Then strip prefix: &ref_path["refs/jin/layers/".len()..]
// This is the pattern from src/commands/list.rs:128-133

// CRITICAL: Test location
// Add tests in the existing #[cfg(test)] mod tests block at end of layer.rs
// Follow naming pattern: test_parse_layer_from_ref_path_<variant>()
```

## Implementation Blueprint

### Data Models and Structure

No new data models. The function uses the existing `Layer` enum:

```rust
// From src/core/layer.rs lines 10-31
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum Layer {
    GlobalBase,          // refs/jin/layers/global
    ModeBase,            // refs/jin/layers/mode/<mode>/_
    ModeScope,           // refs/jin/layers/mode/<mode>/scope/<scope>/_
    ModeScopeProject,    // refs/jin/layers/mode/<mode>/scope/<scope>/project/<project>
    ModeProject,         // refs/jin/layers/mode/<mode>/project/<project>
    ScopeBase,           // refs/jin/layers/scope/<scope>
    ProjectBase,         // refs/jin/layers/project/<project>
    UserLocal,           // refs/jin/layers/local
    WorkspaceActive,     // refs/jin/layers/workspace
}
```

### Implementation Tasks (ordered by dependencies)

```yaml
Task 1: ADD parse_layer_from_ref_path() method to Layer impl block
  - IMPLEMENT: pub fn parse_layer_from_ref_path(ref_path: &str) -> Option<Layer>
  - LOCATION: src/core/layer.rs, after the Display impl (after line 169), before #[cfg(test)]
  - FOLLOW pattern: src/commands/list.rs:110-162 (parse_ref_path function)
  - PATTERN:
    1. Check prefix with ref_path.starts_with("refs/jin/layers/")
    2. Strip prefix and split on '/'
    3. Collect to Vec<&str>
    4. Match on parts.as_slice() with slice patterns
  - GOTCHA: Handle empty segments from double slashes with .filter(|s| !s.is_empty())
  - NAMING: snake_case function name per Rust convention

Task 2: HANDLE each layer type in match expression
  - IMPLEMENT: Match arms for all 9 layer types
  - ORDER: Most specific patterns first (ModeScopeProject before ModeScope)
  - PATTERN:
    * ["global"] => Some(Layer::GlobalBase)
    * ["mode", _, "_"] => Some(Layer::ModeBase)  - _ wildcard matches any mode name
    * ["mode", _, "scope", _, "_"] => Some(Layer::ModeScope)
    * ["mode", _, "scope", _, "project", _] => Some(Layer::ModeScopeProject)
    * ["mode", _, "project", _] => Some(Layer::ModeProject)
    * ["scope", _] => Some(Layer::ScopeBase)
    * ["project", _] => Some(Layer::ProjectBase)
    * ["local"] => Some(Layer::UserLocal)
    * ["workspace"] => Some(Layer::WorkspaceActive)
    * _ => None  - Unknown pattern
  - CRITICAL: Use underscore _ as wildcard for name segments we don't capture
  - CRITICAL: "_" in pattern is literal string (the suffix), not wildcard

Task 3: ADD comprehensive unit tests
  - IMPLEMENT: Tests in #[cfg(test)] mod tests block (after line 295)
  - FOLLOW pattern: src/core/layer.rs:188-295 (existing test structure)
  - NAMING: test_parse_layer_from_ref_path_<variant> for each layer type
  - NAMING: test_parse_layer_from_ref_path_invalid_* for edge cases
  - COVERAGE:
    * Test all 9 layer types with valid paths
    * Test invalid paths (wrong prefix, malformed)
    * Test edge cases (empty string, partial paths)
  - PLACEMENT: Add before closing brace of tests module

Task 4: VERIFY all existing tests still pass
  - RUN: cargo test --lib layer
  - EXPECTED: All tests pass, no new failures
  - FIX: If any existing tests fail, debug and fix implementation
```

### Implementation Patterns & Key Details

```rust
// Pattern 1: Prefix check and strip (from src/commands/list.rs:128-133)
fn parse_layer_from_ref_path(ref_path: &str) -> Option<Layer> {
    // Check prefix
    if !ref_path.starts_with("refs/jin/layers/") {
        return None;
    }

    // Strip prefix
    let path = &ref_path["refs/jin/layers/".len()..];

    // Split and collect, filtering empty segments
    let parts: Vec<&str> = path.split('/').filter(|s| !s.is_empty()).collect();

    // ... pattern matching
}

// Pattern 2: Slice pattern matching (Rust pattern matching)
match parts.as_slice() {
    // Simple single segment
    ["global"] => Some(Layer::GlobalBase),

    // Three segments with middle wildcard, literal "_" suffix
    ["mode", _, "_"] => Some(Layer::ModeBase),

    // Five segments, capture two middle names, literal "_" suffix
    ["mode", _, "scope", _, "_"] => Some(Layer::ModeScope),

    // Six segments - most specific pattern comes first
    ["mode", _, "scope", _, "project", _] => Some(Layer::ModeScopeProject),

    // Four segments
    ["mode", _, "project", _] => Some(Layer::ModeProject),

    // Two segments with wildcard
    ["scope", _] => Some(Layer::ScopeBase),
    ["project", _] => Some(Layer::ProjectBase),

    // Single segments
    ["local"] => Some(Layer::UserLocal),
    ["workspace"] => Some(Layer::WorkspaceActive),

    // Unknown pattern - return None
    _ => None,
}

// Pattern 3: Unit test structure (from src/core/layer.rs:192-203)
#[test]
fn test_parse_layer_from_ref_path_global_base() {
    let result = Layer::parse_layer_from_ref_path("refs/jin/layers/global");
    assert!(result.is_some());
    assert_eq!(result.unwrap(), Layer::GlobalBase);
}

// Pattern 4: Edge case testing
#[test]
fn test_parse_layer_from_ref_path_empty_string() {
    let result = Layer::parse_layer_from_ref_path("");
    assert!(result.is_none());
}

#[test]
fn test_parse_layer_from_ref_path_wrong_prefix() {
    let result = Layer::parse_layer_from_ref_path("refs/other/global");
    assert!(result.is_none());
}

#[test]
fn test_parse_layer_from_ref_path_mode_base_with_suffix() {
    let result = Layer::parse_layer_from_ref_path("refs/jin/layers/mode/development/_");
    assert_eq!(result, Some(Layer::ModeBase));
}

// GOTCHA: The underscore in slice pattern ["mode", _, "_"]
// - First "_" is a wildcard pattern (matches any single segment)
// - Second "_" is a string literal (matches only the string "_")
// This is correct! We want to match the literal "/" suffix
```

### Integration Points

```yaml
NO EXTERNAL INTEGRATION - This is a pure function with no external dependencies

FUTURE INTEGRATION (P1.M2.T1.S2):
  - Will be called from: src/commands/log.rs
  - Usage pattern:
    for ref_path in repo.list_refs("refs/jin/layers/**")? {
        if let Some(layer) = Layer::parse_layer_from_ref_path(&ref_path) {
            // Display history for this layer ref
        }
    }
```

## Validation Loop

### Level 1: Syntax & Style (Immediate Feedback)

```bash
# Run after implementation - fix before proceeding
cargo fmt --check                    # Check formatting
cargo fmt                            # Auto-format if needed
cargo clippy --all-targets           # Lint checks
# Expected: Zero warnings. If clippy suggests changes, apply them.

# Fix any clippy warnings with:
cargo clippy --all-targets --fix
```

### Level 2: Unit Tests (Component Validation)

```bash
# Test the layer module specifically
cargo test --lib layer               # Run all layer.rs tests
cargo test --lib parse_layer         # Run only parse_layer tests

# Run with output for debugging
cargo test --lib parse_layer -- --show-output

# Expected: All tests pass. Watch for:
# - test_parse_layer_from_ref_path_global_base
# - test_parse_layer_from_ref_path_mode_base
# - test_parse_layer_from_ref_path_mode_scope
# - ... (all 9 layer types)
# - test_parse_layer_from_ref_path_empty_string
# - test_parse_layer_from_ref_path_wrong_prefix

# If tests fail:
# 1. Read error output carefully
# 2. Check slice pattern matching logic
# 3. Verify prefix stripping is correct
# 4. Ensure "_" suffix patterns match literal "_", not wildcard
```

### Level 3: Integration Testing (System Validation)

```bash
# Verify existing log command still works
cargo build --release                # Build release binary
./target/release/jin log             # Should work without errors

# If log command fails:
# 1. Check that Layer enum still has all variants
# 2. Verify ref_path() method wasn't modified
# 3. Ensure new function doesn't break existing code

# Manual verification (optional - for P1.M2.T1.S2):
# Create a test repo with commits in multiple layers
# Verify parse_layer_from_ref_path returns correct Layer for each ref path
```

### Level 4: Creative & Domain-Specific Validation

```bash
# Property-based testing (optional but recommended)
# Test that: parse_layer_from_ref_path(path).is_some() implies path is valid
cargo test --lib                     # Run all tests

# Edge case exploration:
# - Paths with extra slashes: "refs/jin/layers//global"
# - Paths with trailing slashes: "refs/jin/layers/global/"
# - Paths without prefix: "layers/global"
# - Non-string input (if applicable)

# Expected: All edge cases return None, no panics
```

## Final Validation Checklist

### Technical Validation

- [ ] All 4 validation levels completed successfully
- [ ] All tests pass: `cargo test --lib layer`
- [ ] No clippy warnings: `cargo clippy --all-targets`
- [ ] Code formatted: `cargo fmt --check` passes
- [ ] Function returns `Option<Layer>` (not `Result`)
- [ ] All 9 layer types have test coverage

### Feature Validation

- [ ] `parse_layer_from_ref_path("refs/jin/layers/global")` returns `Some(Layer::GlobalBase)`
- [ ] `parse_layer_from_ref_path("refs/jin/layers/mode/dev/_")` returns `Some(Layer::ModeBase)`
- [ ] `parse_layer_from_ref_path("refs/jin/layers/mode/dev/scope/api/_")` returns `Some(Layer::ModeScope)`
- [ ] All 9 layer types parse correctly from canonical paths
- [ ] Invalid paths return `None` (empty string, wrong prefix, malformed)
- [ ] `/_` suffix handled correctly for ModeBase and ModeScope

### Code Quality Validation

- [ ] Function placed in correct location (Layer impl block, before tests)
- [ ] Follows existing code patterns from `src/commands/list.rs`
- [ ] Doc comment includes examples for all layer types
- [ ] Tests follow naming pattern: `test_parse_layer_from_ref_path_<variant>`
- [ ] No `todo!()` or `unimplemented!()` macros in final code

### Documentation & Deployment

- [ ] Public function has doc comment with `///` style
- [ ] Doc comment explains the `/_` suffix pattern
- [ ] Examples in doc comment are accurate
- [ ] Function is `pub` so it can be called from `src/commands/log.rs`

---

## Anti-Patterns to Avoid

- ❌ **Don't use `Result<Layer, E>`** - Use `Option<Layer>` instead. Non-matching paths are expected, not errors.
- ❌ **Don't capture mode/scope/project names** - This function only determines layer TYPE. Context is caller's responsibility.
- ❌ **Don't use `.find()` to match `/_` suffix** - Use `.last()` with filter instead. `.find()` greedily matches first underscore.
- ❌ **Don't forget `.filter(|s| !s.is_empty())`** - Without this, paths like `a//b` create empty segments that break pattern matching.
- ❌ **Don't put less specific patterns before more specific** - Match `ModeScopeProject` (6 segments) before `ModeScope` (5 segments).
- ❌ **Don't skip testing edge cases** - Empty strings, wrong prefixes, and partial paths must return `None`, not panic.
- ❌ **Don't modify existing `ref_path()` method** - Add the new function, don't change existing behavior.
- ❌ **Don't add dependencies** - This is a pure parsing function. No I/O, no Git operations.

## Test Cases Reference

### Required Test Cases

```rust
// Positive cases - all 9 layer types
test_parse_layer_from_ref_path_global_base()
test_parse_layer_from_ref_path_mode_base()
test_parse_layer_from_ref_path_mode_scope()
test_parse_layer_from_ref_path_mode_scope_project()
test_parse_layer_from_ref_path_mode_project()
test_parse_layer_from_ref_path_scope_base()
test_parse_layer_from_ref_path_project_base()
test_parse_layer_from_ref_path_user_local()
test_parse_layer_from_ref_path_workspace_active()

// Negative cases - invalid inputs
test_parse_layer_from_ref_path_empty_string()
test_parse_layer_from_ref_path_wrong_prefix()
test_parse_layer_from_ref_path_partial_match()
test_parse_layer_from_ref_path_invalid_suffix()

// Edge cases
test_parse_layer_from_ref_path_with_colon_in_scope_name()  // e.g., "language:javascript"
test_parse_layer_from_ref_path_with_underscore_in_name()    // Mode names can have _
test_parse_layer_from_ref_path_extra_slashes()              // Double slashes
```

### Example Test Values

| Input | Expected Output |
|-------|-----------------|
| `"refs/jin/layers/global"` | `Some(Layer::GlobalBase)` |
| `"refs/jin/layers/mode/development/_"` | `Some(Layer::ModeBase)` |
| `"refs/jin/layers/mode/production/scope/api/_"` | `Some(Layer::ModeScope)` |
| `"refs/jin/layers/mode/dev/scope/api/project/ui"` | `Some(Layer::ModeScopeProject)` |
| `"refs/jin/layers/mode/dev/project/backend"` | `Some(Layer::ModeProject)` |
| `"refs/jin/layers/scope/config"` | `Some(Layer::ScopeBase)` |
| `"refs/jin/layers/project/api-server"` | `Some(Layer::ProjectBase)` |
| `"refs/jin/layers/local"` | `Some(Layer::UserLocal)` |
| `"refs/jin/layers/workspace"` | `Some(Layer::WorkspaceActive)` |
| `""` | `None` |
| `"refs/other/global"` | `None` |
| `"refs/jin/layers"` | `None` |
| `"refs/jin/layers/mode"` | `None` |
