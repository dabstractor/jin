# Log Command Architecture Analysis

## Overview

The `jin log` command displays commit history for all layers in the Jin repository. The current implementation uses a hardcoded list of layers and only checks for ref paths that match the canonical pattern, missing commits from layers created with different path patterns.

## Current Architecture

### 1. Log Command Implementation

**File**: `src/commands/log.rs`

```rust
pub fn run(
    _matches: &ArgMatches,
    context: &Context,
    repo: &JinRepo,
) -> Result<()> {
    // Get hardcoded list of all layers in precedence order
    let all_layers = Layer::all_in_precedence_order();

    for layer in &all_layers {
        // Skip layers that don't apply to current context
        if layer.requires_mode() && context.mode.is_none() {
            continue;
        }
        if layer.requires_scope() && context.scope.is_none() {
            continue;
        }

        // Generate canonical ref path
        let ref_path = layer.ref_path(
            context.mode.as_deref(),
            context.scope.as_deref(),
            context.project.as_deref(),
        );

        // Check if canonical ref exists
        if git_repo.find_reference(&ref_path).is_ok() {
            // Show commit history for this ref
            show_layer_history(repo, &layer, &ref_path)?;
        }
    }

    Ok(())
}
```

### 2. Layer Ref Path Structure

**File**: `src/core/layer.rs` (lines 50-56)

Git ref paths follow this pattern:

```rust
pub fn ref_path(&self, mode: Option<&str>, scope: Option<&str>, project: Option<&str>) -> String {
    match self {
        Layer::Global => "refs/jin/layers/global".to_string(),
        Layer::ModeBase => format!("refs/jin/layers/mode/{}/_", mode.unwrap()),
        Layer::ModeScope => format!("refs/jin/layers/mode/{}/scope/{}/_", mode.unwrap(), scope.unwrap()),
        Layer::ModeProject => format!("refs/jin/layers/mode/{}/project/{}", mode.unwrap(), project.unwrap()),
        Layer::ModeScopeProject => format!("refs/jin/layers/mode/{}/scope/{}/project/{}", mode.unwrap(), scope.unwrap(), project.unwrap()),
        // ... other layers
    }
}
```

**Key insight**: The `/_` suffix is used for layers that can have child refs to avoid Git ref naming conflicts.

### 3. Layer Enumeration

**File**: `src/core/layer.rs` (lines 58-89)

The `Layer` enum provides a hardcoded list of all layers:

```rust
impl Layer {
    pub fn all_in_precedence_order() -> Vec<Layer> {
        vec![
            Layer::Global,           // Layer 1
            Layer::ModeBase,         // Layer 2
            Layer::ScopeBase,        // Layer 3
            Layer::ProjectBase,      // Layer 4
            Layer::Local,            // Layer 5
            Layer::Workspace,        // Layer 6
            Layer::ModeProject,      // Layer 7
            Layer::ModeScope,        // Layer 8
            Layer::ModeScopeProject, // Layer 9
        ]
    }
}
```

## The Bug

### Root Cause

The log command only checks for **canonical ref paths** generated by `layer.ref_path()`. This means:

1. It only finds refs that match the exact path pattern
2. It misses any refs created with different naming patterns
3. It doesn't dynamically discover all refs under `refs/jin/layers/`

### Example of Bug Behavior

From the bug report:

```bash
# Setup
jin mode create testmode && jin mode use testmode
jin scope create lang:rust --mode=testmode && jin scope use lang:rust

# Commit to ModeBase
echo '{"mode": "base"}' > mode.json && jin add mode.json --mode && jin commit -m "Mode base"

# Commit to ModeScope
echo '{"scope": "test"}' > scope.json && jin add scope.json --mode --scope=lang:rust && jin commit -m "Mode scope"

# Run log
jin log
# Result: Only shows "Mode base" commit, missing "Mode scope" commit
```

**Verification**: The commit exists in `refs/jin/layers/mode/testmode/scope/lang:rust/_` but is not displayed.

### Why This Happens

The log command iterates through `Layer::all_in_precedence_order()` and generates canonical ref paths. However:

1. **Context filtering**: When `context.scope` is set, the command skips layers that don't require a scope
2. **Path mismatch**: The canonical ref path might not match the actual ref that was created
3. **Missing discovery**: No dynamic ref discovery under `refs/jin/layers/`

### Expected Behavior

According to PRD ยง18.6: "`jin log [layer]` - Show commit history for layer"

The log command should:

1. **Discover all layer refs** under `refs/jin/layers/` dynamically
2. **Parse each ref path** to determine which layer it belongs to
3. **Display commits** for each ref that exists
4. **Include all layers**: mode-base, mode-scope, mode-project, mode-scope-project, etc.

## Solution Architecture

### Fix Strategy

1. **Replace hardcoded iteration** with dynamic ref discovery
2. **Use Git ref listing** to find all layer refs
3. **Parse ref paths** to extract layer type and context
4. **Display all discovered refs** regardless of canonical pattern

### Implementation Design

**File to modify**: `src/commands/log.rs`

**New approach**:

```rust
pub fn run(_matches: &ArgMatches, context: &Context, repo: &JinRepo) -> Result<()> {
    // 1. Discover all layer refs dynamically
    let all_refs = repo.list_refs("refs/jin/layers/**")?;

    // 2. Group refs by layer type
    let mut layer_refs: HashMap<Layer, Vec<String>> = HashMap::new();

    for ref_path in all_refs {
        if let Some(layer) = parse_layer_from_ref_path(&ref_path) {
            layer_refs.entry(layer).or_default().push(ref_path);
        }
    }

    // 3. Display history for each ref (in precedence order)
    for layer in Layer::all_in_precedence_order() {
        if let Some(refs) = layer_refs.get(&layer) {
            for ref_path in refs {
                show_layer_history(repo, &layer, ref_path)?;
            }
        }
    }

    Ok(())
}

// Helper to parse layer type from ref path
fn parse_layer_from_ref_path(ref_path: &str) -> Option<Layer> {
    // Parse refs/jin/layers/mode/<mode>/_ => Layer::ModeBase
    // Parse refs/jin/layers/mode/<mode>/scope/<scope>/_ => Layer::ModeScope
    // etc.
}
```

### Helper Function Implementation

```rust
fn parse_layer_from_ref_path(ref_path: &str) -> Option<Layer> {
    let parts: Vec<&str> = ref_path.split('/').collect();

    // refs/jin/layers/... => skip first 3 parts
    if parts.len() < 4 || parts[0] != "refs" || parts[1] != "jin" || parts[2] != "layers" {
        return None;
    }

    match parts.get(3) {
        Some(&"global") => Some(Layer::Global),
        Some(&"mode") => {
            // refs/jin/layers/mode/<name>/_
            if parts.get(5) == Some(&"_") {
                return Some(Layer::ModeBase);
            }
            // refs/jin/layers/mode/<name>/scope/<scope>/_
            if parts.get(4) == Some(&"scope") && parts.get(6) == Some(&"_") {
                return Some(Layer::ModeScope);
            }
            // refs/jin/layers/mode/<name>/project/<project>
            if parts.get(4) == Some(&"project") {
                return Some(Layer::ModeProject);
            }
            // refs/jin/layers/mode/<name>/scope/<scope>/project/<project>
            if parts.get(4) == Some(&"scope") && parts.get(6) == Some(&"project") {
                return Some(Layer::ModeScopeProject);
            }
            None
        }
        Some(&"scope") => Some(Layer::ScopeBase),
        Some(&"project") => Some(Layer::ProjectBase),
        Some(&"local") => Some(Layer::Local),
        Some(&"workspace") => Some(Layer::Workspace),
        _ => None,
    }
}
```

## Available Tools

### Git Ref Listing

**File**: `src/git/refs.rs` (lines 109-121)

The codebase already has a `list_refs()` method:

```rust
impl RefOps for JinRepo {
    fn list_refs(&self, pattern: &str) -> Result<Vec<String>> {
        // Uses git2::Reference::list() and filters by pattern
        // Supports glob patterns like "refs/jin/layers/**"
    }
}
```

This can be used directly to discover all layer refs.

## Test Coverage

### Existing Tests

From the bug report, the following test demonstrates the bug:

```bash
cd /tmp/test && rm -rf . && rm -rf /tmp/jin-test && mkdir -p /tmp/jin-test
JIN_DIR=/tmp/jin-test/.jin jin init
jin mode create testmode && jin mode use testmode
jin scope create lang:rust --mode=testmode && jin scope use lang:rust
echo '{"mode": "base"}' > mode.json && jin add mode.json --mode && jin commit -m "Mode base"
echo '{"scope": "test"}' > scope.json && jin add scope.json --mode --scope=lang:rust && jin commit -m "Mode scope"
jin log
# Expected: Both commits visible
# Actual: Only "Mode base" visible
```

### New Tests Needed

After fixing the bug, add tests for:

1. **Dynamic ref discovery**: Verify all layer refs are discovered
2. **Non-canonical ref paths**: Test refs created with different patterns
3. **All 9 layers**: Verify commits from all layers are displayed
4. **Empty layers**: Verify layers with no commits are handled gracefully

## Dependencies

The log fix depends on:

1. **JinRepo::list_refs()** - Already available in `src/git/refs.rs`
2. **Layer enum** - Already defined in `src/core/layer.rs`
3. **Context parsing** - Already available in `src/core/context.rs`

## Impact Assessment

### High-Level Impact

- **User experience**: Significantly improved - users can see all commit history
- **PRD compliance**: Fixes PRD ยง18.6 "`jin log [layer]` - Show commit history for layer"
- **Breaking changes**: None - this is a bug fix
- **Migration needed**: No

### Risk Assessment

- **Low risk**: Changes are isolated to the log command
- **Backward compatible**: Will still show all previously visible refs
- **Test coverage**: Can add integration tests to verify behavior

## References

- **PRD ยง18.6**: "`jin log [layer]` - Show commit history for layer"
- **Implementation files**:
  - `src/commands/log.rs` - Log command implementation
  - `src/core/layer.rs` - Layer definitions and ref path generation
  - `src/git/refs.rs` - Git ref operations (list_refs method)
