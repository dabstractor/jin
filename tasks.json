{
  "backlog": [
    {
      "type": "Phase",
      "id": "P1",
      "title": "Phase 1: Critical PRD Compliance Gaps",
      "status": "Planned",
      "description": "Implement the three critical gaps that violate PRD non-negotiable invariants: .jinmerge conflict resolution workflow, fetch-before-push enforcement, and detached workspace state detection. These gaps block core functionality and must be resolved before Jin can be considered production-ready.",
      "milestones": [
        {
          "type": "Milestone",
          "id": "P1.M1",
          "title": "Milestone 1.1: .jinmerge Conflict Resolution Workflow",
          "status": "Planned",
          "description": "Implement the PRD-mandated .jinmerge file format for conflict resolution. This replaces the current abort-on-conflict behavior with a Git-style conflict resolution workflow that allows users to manually resolve merge conflicts before completing the apply operation.",
          "tasks": [
            {
              "type": "Task",
              "id": "P1.M1.T1",
              "title": "Create .jinmerge File Format Module",
              "status": "Complete",
              "description": "Implement the core data structures and file format for .jinmerge conflict files that show layer-aware conflict markers with full ref paths.",
              "subtasks": [
                {
                  "type": "Subtask",
                  "id": "P1.M1.T1.S1",
                  "title": "Define JinMergeConflict data structures",
                  "status": "Complete",
                  "story_points": 1,
                  "dependencies": [],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: diffy crate cannot support custom conflict markers - custom implementation required (plan/architecture/external_deps.md Section 1.2).\n2. INPUT: None (foundational data structures).\n3. LOGIC: Create JinMergeConflict and ConflictRegion structs in src/merge/jinmerge.rs. Each ConflictRegion must contain layer1_ref (full ref path like 'mode/claude/scope/language:javascript/'), layer1_content, layer2_ref, layer2_content. Do NOT use diffy for marker generation.\n4. OUTPUT: Public structs with public fields for use by apply command (S2) and resolve command (S3)."
                },
                {
                  "type": "Subtask",
                  "id": "P1.M1.T1.S2",
                  "title": "Implement .jinmerge file generation",
                  "status": "Complete",
                  "story_points": 1,
                  "dependencies": [
                    "P1.M1.T1.S1"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: PRD Section 11.3 specifies exact format: '<<<<<<< layer_ref\\ncontent\\n=======\\ncontent\\n>>>>>>> layer_ref' (plan/architecture/codebase_analysis.md Section 2, Gap #1).\n2. INPUT: JinMergeConflict struct from S1 with populated conflict regions.\n3. LOGIC: Implement write_to_file() method that generates .jinmerge files in workspace with Git-style conflict markers. Markers must include full layer ref paths (not 'ours/theirs'). Write file to same path as original but with .jinmerge extension.\n4. OUTPUT: .jinmerge file written to workspace filesystem, returning Result<()> for error handling by apply command."
                },
                {
                  "type": "Subtask",
                  "id": "P1.M1.T1.S3",
                  "title": "Implement .jinmerge file parsing",
                  "status": "Complete",
                  "story_points": 1,
                  "dependencies": [
                    "P1.M1.T1.S2"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: Needed for resolve command to validate resolved files (plan/architecture/codebase_analysis.md Section 4.3).\n2. INPUT: PathBuf pointing to .jinmerge file in workspace.\n3. LOGIC: Implement parse_from_file() function that reads .jinmerge file and extracts conflict regions. Must validate marker format and extract layer ref paths. Return error if file format invalid.\n4. OUTPUT: JinMergeConflict struct with parsed regions for use by resolve command validation."
                },
                {
                  "type": "Subtask",
                  "id": "P1.M1.T1.S4",
                  "title": "Add .jinmerge module to merge mod.rs",
                  "status": "Complete",
                  "story_points": 1,
                  "dependencies": [
                    "P1.M1.T1.S1"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: Follow existing merge module structure (plan/architecture/codebase_analysis.md Section 3.2).\n2. INPUT: jinmerge module exists at src/merge/jinmerge.rs.\n3. LOGIC: Add 'pub mod jinmerge;' to src/merge/mod.rs. Re-export main structs (JinMergeConflict, ConflictRegion) for use by commands module.\n4. OUTPUT: merge::jinmerge module accessible as crate::merge::jinmerge in commands."
                }
              ]
            },
            {
              "type": "Task",
              "id": "P1.M1.T2",
              "title": "Modify Apply Command to Write .jinmerge Files",
              "status": "Complete",
              "description": "Replace the current abort-on-conflict behavior in jin apply with .jinmerge file creation workflow. When conflicts are detected, write .jinmerge files and pause the operation instead of failing.",
              "subtasks": [
                {
                  "type": "Subtask",
                  "id": "P1.M1.T2.S1",
                  "title": "Refactor conflict detection to collect merge results",
                  "status": "Complete",
                  "story_points": 1,
                  "dependencies": [
                    "P1.M1.T1.S4"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: Current code at lines 63-76 in apply.rs aborts on conflicts (plan/architecture/codebase_analysis.md Section 2, Gap #1). Current merged object contains conflict_files Vec<PathBuf>.\n2. INPUT: LayerMergeResult from merge_layers() call in execute() function.\n3. LOGIC: Before aborting, collect file contents for each conflict from merged.merged_files map. For each conflict file, read the base content from each layer involved in conflict. Store as Vec<ConflictFileData> struct with path, base_content, and conflicting layer contents.\n4. OUTPUT: Vec<ConflictFileData> containing all information needed to generate .jinmerge files."
                },
                {
                  "type": "Subtask",
                  "id": "P1.M1.T2.S2",
                  "title": "Generate .jinmerge files for each conflict",
                  "status": "Complete",
                  "story_points": 1,
                  "dependencies": [
                    "P1.M1.T2.S1"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: Use jinmerge module from T1 (plan/architecture/codebase_analysis.md Section 2, Gap #1).\n2. INPUT: Vec<ConflictFileData> from S1 with file contents and layer information.\n3. LOGIC: For each conflict, create JinMergeConflict with ConflictRegion for each conflicting layer. Call write_to_file() to write .jinmerge file to workspace. The .jinmerge file should be in same directory as original file (e.g., .claude/config.json -> .claude/config.json.jinmerge).\n4. OUTPUT: Multiple .jinmerge files written to workspace, returning Result<Vec<PathBuf>> with paths to created files."
                },
                {
                  "type": "Subtask",
                  "id": "P1.M1.T2.S3",
                  "title": "Update apply command to pause instead of abort",
                  "status": "Complete",
                  "story_points": 1,
                  "dependencies": [
                    "P1.M1.T2.S2"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: Current code returns Err(JinError::Other(...)) at line 86 (plan/architecture/codebase_analysis.md Section 2, Gap #1). PRD requires workflow pause, not failure.\n2. INPUT: Vec<PathBuf> of .jinmerge file paths from S2.\n3. LOGIC: Remove the Err return for conflicts. Instead, display user-friendly message: 'Merge conflicts detected in N files. .jinmerge files created. Resolve conflicts manually, then run \"jin resolve <files>\" to continue.' Exit with Ok(()) after creating files. Do NOT proceed with apply operation.\n4. OUTPUT: Ok(()) returning from execute() after writing conflict files, without applying any changes to workspace."
                },
                {
                  "type": "Subtask",
                  "id": "P1.M1.T2.S4",
                  "title": "Create conflict state tracking file",
                  "status": "Complete",
                  "story_points": 1,
                  "dependencies": [
                    "P1.M1.T2.S3"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: Needed for resolve command to know which operation to resume (plan/architecture/codebase_analysis.md Section 2, Gap #1).\n2. INPUT: Vec<PathBuf> of .jinmerge file paths, original apply command args.\n3. LOGIC: Create .jin/apply-in-progress file in JSON format with fields: operation_type (\"apply\"), conflict_files (array of paths), original_args (serialized ApplyArgs), timestamp (ISO 8601). Write to .jin/ directory.\n4. OUTPUT: State file persisted for later resume by resolve command."
                }
              ]
            },
            {
              "type": "Task",
              "id": "P1.M1.T3",
              "title": "Implement Resolve Command",
              "status": "Planned",
              "description": "Create the jin resolve command that completes the conflict resolution workflow. Users run this command after manually resolving .jinmerge conflicts to continue the interrupted apply operation.",
              "subtasks": [
                {
                  "type": "Subtask",
                  "id": "P1.M1.T3.S1",
                  "title": "Add resolve CLI arguments",
                  "status": "Planned",
                  "story_points": 1,
                  "dependencies": [],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: Follow clap derive pattern from existing commands (plan/architecture/external_deps.md Section 1.6).\n2. INPUT: User provides paths to resolved files on command line.\n3. LOGIC: Add ResolveArgs struct to src/cli/mod.rs with 'paths: Vec<PathBuf>' field for resolved file paths. Add '--all' flag for resolving all conflicts at once. Derive Parser and Debug traits.\n4. OUTPUT: ResolveArgs struct for use by resolve command implementation."
                },
                {
                  "type": "Subtask",
                  "id": "P1.M1.T3.S2",
                  "title": "Implement resolve validation logic",
                  "status": "Planned",
                  "story_points": 1,
                  "dependencies": [
                    "P1.M1.T3.S1",
                    "P1.M1.T1.S3"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: Must validate .jinmerge files are fully resolved (plan/architecture/codebase_analysis.md Section 2, Gap #1).\n2. INPUT: ResolveArgs with file paths, .jin/apply-in-progress state file.\n3. LOGIC: For each path in args.paths, check if .jinmerge file exists. If yes, parse with parse_from_file() and validate no conflict markers remain (search for '<<<<<<<' in file content). If conflict markers still present, return Err. If .jinmerge doesn't exist but path in state file, verify file was modified.\n4. OUTPUT: Result<()> indicating all conflicts resolved, or Err with details of unresolved conflicts."
                },
                {
                  "type": "Subtask",
                  "id": "P1.M1.T3.S3",
                  "title": "Resume apply operation after resolution",
                  "status": "Planned",
                  "story_points": 2,
                  "dependencies": [
                    "P1.M1.T3.S2"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: Must resume the original apply operation from state file (plan/architecture/codebase_analysis.md Section 2, Gap #1).\n2. INPUT: Validated resolved files from S2, .jin/apply-in-progress state file with original args.\n3. LOGIC: Load original ApplyArgs from state file. Call apply::execute() with original args, but skip the conflict detection phase (files already resolved). Remove .jinmerge files after successful apply. Delete .jin/apply-in-progress state file. Display success message.\n4. OUTPUT: Ok(()) after completing apply, returning to normal workflow."
                },
                {
                  "type": "Subtask",
                  "id": "P1.M1.T3.S4",
                  "title": "Add resolve command to CLI",
                  "status": "Planned",
                  "story_points": 1,
                  "dependencies": [
                    "P1.M1.T3.S3"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: Add to subcommands list in src/main.rs (plan/architecture/codebase_analysis.md Section 1.1).\n2. INPUT: resolve command implementation exists in src/commands/resolve.rs.\n3. LOGIC: Add Resolve(ResolveArgs) variant to Commands enum in src/cli/mod.rs. Add command registration in src/main.rs with 'resolve' name and description 'Complete conflict resolution workflow'.\n4. OUTPUT: 'jin resolve <paths>' command available to users."
                }
              ]
            },
            {
              "type": "Task",
              "id": "P1.M1.T4",
              "title": "Update Status Command for Conflict State",
              "status": "Planned",
              "description": "Modify jin status to display when there's an in-progress apply operation with pending conflict resolutions. This provides users with visibility into the conflict resolution workflow state.",
              "subtasks": [
                {
                  "type": "Subtask",
                  "id": "P1.M1.T4.S1",
                  "title": "Check for in-progress apply operation",
                  "status": "Planned",
                  "story_points": 1,
                  "dependencies": [],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: Status command at src/commands/status.rs needs to detect .jin/apply-in-progress (plan/architecture/codebase_analysis.md Section 2, Gap #1).\n2. INPUT: Current workspace state, .jin directory contents.\n3. LOGIC: In execute() function, check if .jin/apply-in-progress file exists. If yes, parse JSON to get conflict_files list and timestamp. Store for display.\n4. OUTPUT: Option<InProgressApply> struct with conflict info, or None if no in-progress operation."
                },
                {
                  "type": "Subtask",
                  "id": "P1.M1.T4.S2",
                  "title": "Display conflict state in status output",
                  "status": "Planned",
                  "story_points": 1,
                  "dependencies": [
                    "P1.M1.T4.S1"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: PRD requires status to show pending resolutions (plan/architecture/codebase_analysis.md Section 2, Gap #1).\n2. INPUT: Option<InProgressApply> from S1 with conflict file paths.\n3. LOGIC: If in-progress apply exists, add section to status output: 'Merge conflicts (N files):' followed by list of conflicted files. Add 'Resolve with: jin resolve <files>' instruction. Show timestamp of when conflicts were detected.\n4. OUTPUT: Enhanced status output including conflict state information."
                }
              ]
            },
            {
              "type": "Task",
              "id": "P1.M1.T5",
              "title": "Add Integration Tests for Conflict Workflow",
              "status": "Planned",
              "description": "Create comprehensive integration tests for the .jinmerge conflict resolution workflow. Tests must cover end-to-end scenarios from conflict detection through resolution.",
              "subtasks": [
                {
                  "type": "Subtask",
                  "id": "P1.M1.T5.S1",
                  "title": "Test .jinmerge file creation",
                  "status": "Planned",
                  "story_points": 1,
                  "dependencies": [
                    "P1.M1.T2.S4"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: Use TestFixture pattern from tests/common/fixtures.rs (plan/architecture/test_analysis.md Section 1.1).\n2. INPUT: Two layers with conflicting file contents.\n3. LOGIC: Create test that stages conflicting files to different layers, runs 'jin apply', and verifies .jinmerge files are created in workspace. Assert file format matches PRD spec with layer ref paths. Use absolute paths from fixture, not set_current_dir().\n4. OUTPUT: Passing test verifying .jinmerge file creation and format."
                },
                {
                  "type": "Subtask",
                  "id": "P1.M1.T5.S2",
                  "title": "Test resolve command workflow",
                  "status": "Planned",
                  "story_points": 1,
                  "dependencies": [
                    "P1.M1.T5.S1",
                    "P1.M1.T3.S4"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: Test must simulate user manually resolving conflicts (plan/architecture/test_analysis.md Section 1.1).\n2. INPUT: Workspace with .jinmerge files from S1.\n3. LOGIC: Create test that manually edits .jinmerge file to remove conflict markers, then runs 'jin resolve' with the file path. Verify original file is updated with resolved content and .jinmerge file is deleted. Assert state file is cleaned up.\n4. OUTPUT: Passing test verifying complete resolve workflow."
                },
                {
                  "type": "Subtask",
                  "id": "P1.M1.T5.S3",
                  "title": "Test status shows conflict state",
                  "status": "Planned",
                  "story_points": 1,
                  "dependencies": [
                    "P1.M1.T5.S1",
                    "P1.M1.T4.S2"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: Use assert_status_has_conflict() helper from tests/common/assertions.rs (plan/architecture/test_analysis.md Section 8.1).\n2. INPUT: Workspace with in-progress apply from S1.\n3. LOGIC: Create test that runs 'jin status' after conflicts are detected and verifies output includes conflict file list and resolve instruction. Parse status output and assert conflict section exists with correct file count.\n4. OUTPUT: Passing test verifying status command integration."
                },
                {
                  "type": "Subtask",
                  "id": "P1.M1.T5.S4",
                  "title": "Test error handling for unresolved conflicts",
                  "status": "Planned",
                  "story_points": 1,
                  "dependencies": [
                    "P1.M1.T5.S2"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: Test must validate resolve rejects incomplete resolutions (plan/architecture/test_analysis.md Section 5.2).\n2. INPUT: Workspace with .jinmerge file still containing conflict markers.\n3. LOGIC: Create test that runs 'jin resolve' on file with unresolved conflict markers. Verify command returns Err with helpful error message listing which files still have conflicts. Do NOT modify workspace.\n4. OUTPUT: Passing test validating error handling."
                }
              ]
            }
          ]
        },
        {
          "type": "Milestone",
          "id": "P1.M2",
          "title": "Milestone 1.2: Fetch-Before-Push Enforcement",
          "status": "Planned",
          "description": "Implement the PRD-mandated fetch-before-push invariant to prevent data loss in team collaboration scenarios. The push command must automatically fetch from remote and reject pushes when local state is behind remote.",
          "tasks": [
            {
              "type": "Task",
              "id": "P1.M2.T1",
              "title": "Add Automatic Fetch to Push Command",
              "status": "Planned",
              "description": "Modify the push command to automatically call fetch before pushing. This ensures the local state is compared against the latest remote state before any push operation.",
              "subtasks": [
                {
                  "type": "Subtask",
                  "id": "P1.M2.T1.S1",
                  "title": "Call fetch at start of push execute",
                  "status": "Planned",
                  "story_points": 1,
                  "dependencies": [],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: Current push.rs has NO fetch call (plan/architecture/codebase_analysis.md Section 2, Gap #2). Fetch command at src/commands/fetch.rs can be called directly.\n2. INPUT: PushArgs struct in push::execute() function.\n3. LOGIC: At the very start of push::execute(), after loading JinConfig, call 'super::fetch::execute()?' to fetch from remote. This will update remote tracking refs in the Jin repository. Ensure any fetch errors are propagated to user.\n4. OUTPUT: Updated remote refs in local Jin repository, ready for comparison in S2."
                },
                {
                  "type": "Subtask",
                  "id": "P1.M2.T1.S2",
                  "title": "Capture and display fetch results",
                  "status": "Planned",
                  "story_points": 1,
                  "dependencies": [
                    "P1.M2.T1.S1"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: Users should see what was fetched (plan/architecture/codebase_analysis.md Section 2, Gap #2).\n2. INPUT: Result from fetch::execute() call.\n3. LOGIC: Capture the fetch result (updated refs count, file changes). Display brief message: 'Fetched from remote: N layer(s) updated'. Don't show full fetch details (push command has its own output), just confirm fetch succeeded.\n4. OUTPUT: User notification that fetch completed before push proceeds."
                }
              ]
            },
            {
              "type": "Task",
              "id": "P1.M2.T2",
              "title": "Implement Local vs Remote Comparison",
              "status": "Planned",
              "description": "Add logic to compare local and remote refs after fetching. Detect if local commits are behind remote commits (divergent histories) to prevent data loss.",
              "subtasks": [
                {
                  "type": "Subtask",
                  "id": "P1.M2.T2.S1",
                  "title": "Create ref comparison utility function",
                  "status": "Planned",
                  "story_points": 1,
                  "dependencies": [],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: git2 provides graph_descendant_of() for ancestry checking (plan/architecture/external_deps.md Section 4.2).\n2. INPUT: JinRepo instance, local layer ref name (e.g., 'mode/claude'), remote ref name.\n3. LOGIC: Create function is_behind_remote() in src/git/repo.rs or src/commands/push.rs. Use git2::Repository::graph_descendant_of() to check if local commit is ancestor of remote commit. Return Result<bool> where true means local is behind. Handle missing refs gracefully.\n4. OUTPUT: Boolean indicating whether local ref is behind remote ref."
                },
                {
                  "type": "Subtask",
                  "id": "P1.M2.T2.S2",
                  "title": "Add DetachedWorkspace error variant",
                  "status": "Planned",
                  "story_points": 1,
                  "dependencies": [],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: New error type needed for push rejection (plan/architecture/codebase_analysis.md Section 2, Gap #2). thiserror supports custom errors (plan/architecture/external_deps.md Section 1.4).\n2. INPUT: Layer ref name, local commit SHA, remote commit SHA.\n3. LOGIC: Add PushBehindRemote variant to JinError enum in src/core/error.rs with fields: layer_name (String), local_commit (String), remote_commit (String), hint (String). Implement thiserror derive with error message including hint.\n4. OUTPUT: New error type for use in push command."
                },
                {
                  "type": "Subtask",
                  "id": "P1.M2.T2.S3",
                  "title": "Compare refs before pushing",
                  "status": "Planned",
                  "story_points": 1,
                  "dependencies": [
                    "P1.M2.T2.S1",
                    "P1.M2.T2.S2"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: Must check ALL layers being pushed (plan/architecture/codebase_analysis.md Section 2, Gap #2).\n2. INPUT: List of layer refs to push, JinRepo instance, --force flag from PushArgs.\n3. LOGIC: After fetch in S1, for each layer ref to push, call is_behind_remote(). If ANY ref is behind and --force not set, return Err(JinError::PushBehindRemote) with hint 'Run \"jin pull\" to update local state first, or use --force to override'. If --force is set, display warning but allow push.\n4. OUTPUT: Ok(()) if all refs up-to-date or force flag set, Err otherwise."
                }
              ]
            },
            {
              "type": "Task",
              "id": "P1.M2.T3",
              "title": "Add Integration Tests for Push Enforcement",
              "status": "Planned",
              "description": "Create integration tests for fetch-before-push enforcement covering scenarios where local is behind, ahead, and divergent from remote.",
              "subtasks": [
                {
                  "type": "Subtask",
                  "id": "P1.M2.T3.S1",
                  "title": "Test push rejected when behind remote",
                  "status": "Planned",
                  "story_points": 1,
                  "dependencies": [
                    "P1.M2.T2.S3"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: Use TestFixture with remote repository setup (plan/architecture/test_analysis.md Section 1.1).\n2. INPUT: Two fixtures: local_repo and remote_repo with shared remote origin.\n3. LOGIC: Create test where remote has newer commit than local. Run 'jin push' and verify command returns Err with PushBehindRemote error. Assert error message includes hint to run 'jin pull'. Verify no push occurred.\n4. OUTPUT: Passing test validating push rejection when behind."
                },
                {
                  "type": "Subtask",
                  "id": "P1.M2.T3.S2",
                  "title": "Test push succeeds when force flag set",
                  "status": "Planned",
                  "story_points": 1,
                  "dependencies": [
                    "P1.M2.T3.S1"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: --force flag should override the check (plan/architecture/codebase_analysis.md Section 2, Gap #2).\n2. INPUT: Local repo behind remote with PushArgs.force = true.\n3. LOGIC: Create test where remote is ahead, but push command run with --force flag. Verify fetch still occurs, but push proceeds without error. Assert warning message displayed about forced push.\n4. OUTPUT: Passing test validating force override behavior."
                },
                {
                  "type": "Subtask",
                  "id": "P1.M2.T3.S3",
                  "title": "Test push succeeds when up-to-date",
                  "status": "Planned",
                  "story_points": 1,
                  "dependencies": [
                    "P1.M2.T3.S1"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: Normal case should work (plan/architecture/test_analysis.md Section 5.2).\n2. INPUT: Local and remote repos with same commit SHA.\n3. LOGIC: Create test where local is not behind remote (same commit or ahead). Run 'jin push' and verify it succeeds normally. Assert fetch occurs before push. Verify refs updated correctly on remote.\n4. OUTPUT: Passing test for normal push flow."
                }
              ]
            }
          ]
        },
        {
          "type": "Milestone",
          "id": "P1.M3",
          "title": "Milestone 1.3: Detached Workspace State Detection",
          "status": "Planned",
          "description": "Implement detection and prevention of detached workspace states. This enforces the PRD non-negotiable invariant that the workspace must always be attached to a valid layer commit.",
          "tasks": [
            {
              "type": "Task",
              "id": "P1.M3.T1",
              "title": "Define Detached Workspace State",
              "status": "Planned",
              "description": "Add the DetachedWorkspace error type and define what constitutes a detached workspace state in the context of Jin's architecture.",
              "subtasks": [
                {
                  "type": "Subtask",
                  "id": "P1.M3.T1.S1",
                  "title": "Add DetachedWorkspace error variant",
                  "status": "Planned",
                  "story_points": 1,
                  "dependencies": [],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: New error needed for workspace validation (plan/architecture/codebase_analysis.md Section 2, Gap #3). thiserror fully supports custom errors (plan/architecture/external_deps.md Section 1.4).\n2. INPUT: Workspace state details, expected layer ref.\n3. LOGIC: Add DetachedWorkspace variant to JinError enum in src/core/error.rs with fields: workspace_commit (Option<String>), expected_layer_ref (String), recovery_hint (String). Implement thiserror derive with descriptive error message and recovery hint.\n4. OUTPUT: New error type usable across workspace operations."
                },
                {
                  "type": "Subtask",
                  "id": "P1.M3.T1.S2",
                  "title": "Document detached workspace conditions",
                  "status": "Planned",
                  "story_points": 1,
                  "dependencies": [
                    "P1.M3.T1.S1"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: PRD Section 19.3 and 25 define invariants (plan/architecture/codebase_analysis.md Section 2, Gap #3).\n2. INPUT: PRD text on workspace invariants.\n3. LOGIC: Create documentation in src/staging/workspace.rs describing detached workspace conditions: (1) Workspace files don't match any known layer merge result, (2) Workspace metadata references commits that no longer exist, (3) Active context references deleted modes/scopes. Add rustdoc comments explaining each condition.\n4. OUTPUT: Inline documentation for developers implementing validation."
                }
              ]
            },
            {
              "type": "Task",
              "id": "P1.M3.T2",
              "title": "Implement Workspace Validation Logic",
              "status": "Planned",
              "description": "Create the validation function that checks if the workspace is attached to a valid layer commit. This function will be called before destructive operations.",
              "subtasks": [
                {
                  "type": "Subtask",
                  "id": "P1.M3.T2.S1",
                  "title": "Implement validate_workspace_attached function",
                  "status": "Planned",
                  "story_points": 2,
                  "dependencies": [
                    "P1.M3.T1.S2"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: Validation must check workspace state against active context (plan/architecture/codebase_analysis.md Section 2, Gap #3). Use Git detached HEAD detection pattern (plan/architecture/external_deps.md Section 3, Q2).\n2. INPUT: Workspace instance, ProjectContext with active mode/scope/project.\n3. LOGIC: Implement validate_workspace_attached() in src/staging/workspace.rs. Get active layer ref from context (e.g., 'refs/jin/layers/mode/claude'). Get workspace's current commit from .jin/workspace/head. Get layer's current commit from JinRepo. Compare: if workspace_commit != layer_commit, return Err(DetachedWorkspace). Also verify workspace_commit exists in Git object database.\n4. OUTPUT: Result<()> with Ok() if attached, Err(DetachedWorkspace) if detached with recovery hint."
                },
                {
                  "type": "Subtask",
                  "id": "P1.M3.T2.S2",
                  "title": "Add workspace metadata validation",
                  "status": "Planned",
                  "story_points": 1,
                  "dependencies": [
                    "P1.M3.T2.S1"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: Metadata must reference valid commits (plan/architecture/codebase_analysis.md Section 2, Gap #3).\n2. INPUT: Workspace metadata from .jin/workspace/metadata.json.\n3. LOGIC: In validate_workspace_attached(), also validate workspace metadata. Parse .jin/workspace/metadata.json and verify all referenced commits exist via repo.find_commit(). If any commit is missing (deleted from history), return Err(DetachedWorkspace) with hint to run 'jin repair'.\n4. OUTPUT: Enhanced validation checking metadata consistency."
                },
                {
                  "type": "Subtask",
                  "id": "P1.M3.T2.S3",
                  "title": "Validate active context references",
                  "status": "Planned",
                  "story_points": 1,
                  "dependencies": [
                    "P1.M3.T2.S2"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: Context may reference deleted modes/scopes (plan/architecture/codebase_analysis.md Section 2, Gap #3).\n2. INPUT: ProjectContext with active mode/scope/project.\n3. LOGIC: In validate_workspace_attached(), verify active mode and scope refs exist. Use repo.ref_exists() to check 'refs/jin/modes/{active_mode}' and 'refs/jin/scopes/{active_scope}'. If any ref missing, return Err(DetachedWorkspace) with hint to activate different mode/scope.\n4. OUTPUT: Complete validation covering all three detached conditions."
                }
              ]
            },
            {
              "type": "Task",
              "id": "P1.M3.T3",
              "title": "Integrate Validation into Destructive Operations",
              "status": "Planned",
              "description": "Call workspace validation before operations that could create or exacerbate detached states. This provides early detection and prevents operations on invalid workspaces.",
              "subtasks": [
                {
                  "type": "Subtask",
                  "id": "P1.M3.T3.S1",
                  "title": "Add validation to reset --hard command",
                  "status": "Planned",
                  "story_points": 1,
                  "dependencies": [
                    "P1.M3.T2.S3"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: reset --hard is destructive (plan/architecture/codebase_analysis.md Section 2, Gap #3). Command at src/commands/reset.rs.\n2. INPUT: ResetArgs with --hard flag set.\n3. LOGIC: In reset::execute(), before performing hard reset, call workspace::validate_workspace_attached()? to ensure workspace is in valid state. If validation fails, abort reset operation and propagate error to user. This prevents resetting an already-detached workspace.\n4. OUTPUT: Reset command rejects operations on detached workspaces."
                },
                {
                  "type": "Subtask",
                  "id": "P1.M3.T3.S2",
                  "title": "Add validation to apply --force command",
                  "status": "Planned",
                  "story_points": 1,
                  "dependencies": [
                    "P1.M3.T3.S1"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: apply --force can overwrite workspace (plan/architecture/codebase_analysis.md Section 2, Gap #3). Command at src/commands/apply.rs.\n2. INPUT: ApplyArgs with --force flag set.\n3. LOGIC: In apply::execute(), when --force flag is set, call workspace::validate_workspace_attached()? before proceeding with force apply. If workspace is detached, return Err with recovery hint instead of forcing operation. This prevents compounding detached states.\n4. OUTPUT: Apply --force validates workspace before making changes."
                },
                {
                  "type": "Subtask",
                  "id": "P1.M3.T3.S3",
                  "title": "Add validation to checkout command",
                  "status": "Planned",
                  "story_points": 1,
                  "dependencies": [
                    "P1.M3.T3.S2"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: checkout changes workspace state (plan/architecture/codebase_analysis.md Section 2, Gap #3).\n2. INPUT: CheckoutArgs with target layer ref.\n3. LOGIC: In checkout::execute(), call workspace::validate_workspace_attached()? to ensure current workspace is valid before switching to different layer. If current workspace is detached, abort checkout and direct user to repair.\n4. OUTPUT: Checkout validates current state before switching."
                }
              ]
            },
            {
              "type": "Task",
              "id": "P1.M3.T4",
              "title": "Add Detached State Detection to Repair Command",
              "status": "Planned",
              "description": "Extend the repair command with --check flag to detect and report detached workspace states. This provides users with a diagnostic tool when they encounter detached workspace errors.",
              "subtasks": [
                {
                  "type": "Subtask",
                  "id": "P1.M3.T4.S1",
                  "title": "Add --check flag to repair command",
                  "status": "Planned",
                  "story_points": 1,
                  "dependencies": [],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: repair command exists at src/commands/repair.rs (plan/architecture/codebase_analysis.md Section 2, Gap #3).\n2. INPUT: RepairArgs struct.\n3. LOGIC: Add 'check: bool' field to RepairArgs in src/cli/mod.rs. Default to false. In repair::execute(), if check is true, run diagnostic checks and report issues without fixing them. Add 'jin repair --check' command to CLI.\n4. OUTPUT: New repair --check command for diagnostics."
                },
                {
                  "type": "Subtask",
                  "id": "P1.M3.T4.S2",
                  "title": "Implement detached state check",
                  "status": "Planned",
                  "story_points": 1,
                  "dependencies": [
                    "P1.M3.T4.S1",
                    "P1.M3.T2.S3"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: Reuse validation logic from T2 (plan/architecture/codebase_analysis.md Section 2, Gap #3).\n2. INPUT: Workspace state, active context.\n3. LOGIC: In repair::execute(), when --check flag is set, call workspace::validate_workspace_attached(). If returns Err(DetachedWorkspace), collect error details and add to issues_found list with 'Detached workspace' category. Display check results showing if workspace is attached or detached with recovery hint.\n4. OUTPUT: Repair --check reports detached state with recovery instructions."
                }
              ]
            },
            {
              "type": "Task",
              "id": "P1.M3.T5",
              "title": "Add Integration Tests for Workspace Validation",
              "status": "Planned",
              "description": "Create integration tests for detached workspace detection covering scenarios where workspace becomes detached and validation prevents destructive operations.",
              "subtasks": [
                {
                  "type": "Subtask",
                  "id": "P1.M3.T5.S1",
                  "title": "Test validation detects detached workspace",
                  "status": "Planned",
                  "story_points": 1,
                  "dependencies": [
                    "P1.M3.T2.S3"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: Use TestFixture with workspace manipulation (plan/architecture/test_analysis.md Section 1.1).\n2. INPUT: Workspace with manually corrupted .jin/workspace/head file.\n3. LOGIC: Create test that modifies .jin/workspace/head to point to non-existent commit. Then calls workspace::validate_workspace_attached() and asserts it returns Err(DetachedWorkspace). Verify error message contains recovery hint.\n4. OUTPUT: Passing test validating detection logic."
                },
                {
                  "type": "Subtask",
                  "id": "P1.M3.T5.S2",
                  "title": "Test reset --hard rejected when detached",
                  "status": "Planned",
                  "story_points": 1,
                  "dependencies": [
                    "P1.M3.T5.S1",
                    "P1.M3.T3.S1"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: Test must use absolute paths (plan/architecture/test_analysis.md Section 5.1).\n2. INPUT: Workspace in detached state, ResetArgs with --hard.\n3. LOGIC: Create test that detaches workspace (corrupts head), then runs 'jin reset --hard mode/claude'. Verify command returns Err(DetachedWorkspace) without modifying workspace. Assert error includes recovery hint.\n4. OUTPUT: Passing test validating reset protection."
                },
                {
                  "type": "Subtask",
                  "id": "P1.M3.T5.S3",
                  "title": "Test repair --check detects detached state",
                  "status": "Planned",
                  "story_points": 1,
                  "dependencies": [
                    "P1.M3.T5.S1",
                    "P1.M3.T4.S2"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: Repair test expectations need updates (plan/architecture/test_analysis.md Section 2.5).\n2. INPUT: Workspace in detached state, RepairArgs with --check.\n3. LOGIC: Create test with detached workspace, runs 'jin repair --check'. Verifies command returns Ok(()) but reports '1 issue found' including detached workspace details. Check output contains recovery hint.\n4. OUTPUT: Passing test validating repair diagnostics."
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "type": "Phase",
      "id": "P2",
      "title": "Phase 2: Feature Completeness and Test Suite",
      "status": "Planned",
      "description": "Address medium-priority gaps for feature completeness (3-way merge in pull, export committed files, active context notifications) and fix the 12 failing unit tests to achieve 100% test reliability.",
      "milestones": [
        {
          "type": "Milestone",
          "id": "P2.M1",
          "title": "Milestone 2.1: 3-Way Merge in Pull Command",
          "status": "Planned",
          "description": "Extend the pull command to handle non-fast-forward cases using proper 3-way merge instead of only supporting fast-forward updates. This enables team collaboration scenarios with divergent histories.",
          "tasks": [
            {
              "type": "Task",
              "id": "P2.M1.T1",
              "title": "Detect Fast-Forward vs Divergent Histories",
              "status": "Planned",
              "description": "Add logic to detect when a pull operation is fast-forward vs divergent. Divergent histories require 3-way merge instead of simple ref updates.",
              "subtasks": [
                {
                  "type": "Subtask",
                  "id": "P2.M1.T1.S1",
                  "title": "Implement merge base detection",
                  "status": "Planned",
                  "story_points": 1,
                  "dependencies": [],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: git2 provides merge_base() for finding common ancestor (plan/architecture/external_deps.md Section 3, Q3). Current pull.rs at line 49 has TODO.\n2. INPUT: JinRepo instance, local layer ref, remote layer ref.\n3. LOGIC: Create function detect_merge_type() in src/commands/pull.rs. Use git2::Repository::merge_base() to find common ancestor of local and remote commits. If merge_base == local commit, it's fast-forward. If merge_base is different, it's divergent (needs 3-way merge).\n4. OUTPUT: MergeType enum (FastForward or Divergent) for use in pull logic."
                },
                {
                  "type": "Subtask",
                  "id": "P2.M1.T1.S2",
                  "title": "Add MergeType enum",
                  "status": "Planned",
                  "story_points": 1,
                  "dependencies": [
                    "P2.M1.T1.S1"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: Needed for control flow in pull command (plan/architecture/codebase_analysis.md Section 2, Gap #4).\n2. INPUT: Result from merge_base detection.\n3. LOGIC: Define MergeType enum in src/commands/pull.rs with variants FastForward and Divergent. Implement helper methods is_fast_forward() and needs_merge(). Use to control flow in execute().\n4. OUTPUT: Enum type for merge detection results."
                }
              ]
            },
            {
              "type": "Task",
              "id": "P2.M1.T2",
              "title": "Implement 3-Way Merge for Divergent Histories",
              "status": "Planned",
              "description": "Use the existing text merge infrastructure to perform 3-way merge when histories have diverged. Handle conflicts using the .jinmerge workflow from Phase 1.",
              "subtasks": [
                {
                  "type": "Subtask",
                  "id": "P2.M1.T2.S1",
                  "title": "Extract file contents from three commits",
                  "status": "Planned",
                  "story_points": 1,
                  "dependencies": [
                    "P2.M1.T1.S2"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: 3-way merge needs base, local, remote contents (plan/architecture/external_deps.md Section 3, Q3). src/merge/text.rs already has merge_files().\n2. INPUT: Merge base commit, local commit, remote commit, file path.\n3. LOGIC: For each file in layer updates, extract content from three commits: use repo.find_blob() to get file content at base, local, and remote commits. Pass three contents to text_merge::merge_files() which returns MergeResult with merged content or conflicts.\n4. OUTPUT: Vec<MergeResult> for all updated files."
                },
                {
                  "type": "Subtask",
                  "id": "P2.M1.T2.S2",
                  "title": "Handle merge conflicts with .jinmerge workflow",
                  "status": "Planned",
                  "story_points": 2,
                  "dependencies": [
                    "P2.M1.T2.S1"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: Reuse .jinmerge workflow from P1.M1 (plan/architecture/codebase_analysis.md Section 2, Gap #4).\n2. INPUT: MergeResult with conflicts from text_merge.\n3. LOGIC: When merge_files() returns Conflict variant, use same workflow as apply command: write .jinmerge file with layer ref markers, pause operation, create .jin/pull-in-progress state file. Display message to user about resolving conflicts before running 'jin resolve'.\n4. OUTPUT: .jinmerge files created for pull conflicts, operation paused."
                },
                {
                  "type": "Subtask",
                  "id": "P2.M1.T2.S3",
                  "title": "Write merged files to layer",
                  "status": "Planned",
                  "story_points": 1,
                  "dependencies": [
                    "P2.M1.T2.S2"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: For clean merges, write result to layer (plan/architecture/codebase_analysis.md Section 2, Gap #4).\n2. INPUT: MergeResult with Clean variant containing merged content.\n3. LOGIC: When merge_files() returns Clean(content), use LayerTransaction to add the merged file to the appropriate layer. Ensure transaction is atomic across all layer updates. After all files processed, commit transaction.\n4. OUTPUT: Layer updated with merged content, transaction committed."
                }
              ]
            },
            {
              "type": "Task",
              "id": "P2.M1.T3",
              "title": "Add Integration Tests for 3-Way Merge",
              "status": "Planned",
              "description": "Create integration tests for 3-way merge in pull covering fast-forward, divergent clean merge, and divergent with conflicts scenarios.",
              "subtasks": [
                {
                  "type": "Subtask",
                  "id": "P2.M1.T3.S1",
                  "title": "Test fast-forward merge still works",
                  "status": "Planned",
                  "story_points": 1,
                  "dependencies": [
                    "P2.M1.T2.S3"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: Regression test for existing functionality (plan/architecture/test_analysis.md Section 5.2).\n2. INPUT: Local repo behind remote (fast-forward scenario).\n3. LOGIC: Create test where remote has new commit on top of local. Run 'jin pull' and verify layer is updated to remote commit. Verify merge was fast-forward (no merge commit created).\n4. OUTPUT: Passing test validating fast-forward behavior unchanged."
                },
                {
                  "type": "Subtask",
                  "id": "P2.M1.T3.S2",
                  "title": "Test divergent clean merge",
                  "status": "Planned",
                  "story_points": 1,
                  "dependencies": [
                    "P2.M1.T3.S1"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: Test new 3-way merge capability (plan/architecture/test_analysis.md Section 1.1).\n2. INPUT: Local and remote have diverged from common ancestor with different files.\n3. LOGIC: Create test where local modified file A, remote modified file B (no overlap). Run 'jin pull' and verify both files are present in merged result. Verify layer ref is updated to merge commit.\n4. OUTPUT: Passing test for clean 3-way merge."
                },
                {
                  "type": "Subtask",
                  "id": "P2.M1.T3.S3",
                  "title": "Test divergent merge with conflicts",
                  "status": "Planned",
                  "story_points": 1,
                  "dependencies": [
                    "P2.M1.T3.S2"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: Should create .jinmerge files (plan/architecture/codebase_analysis.md Section 2, Gap #4).\n2. INPUT: Local and remote modified same file with conflicting content.\n3. LOGIC: Create test where both local and remote modified same file with different content. Run 'jin pull' and verify .jinmerge file is created. Verify pull operation paused without modifying layer.\n4. OUTPUT: Passing test for conflict handling in pull."
                }
              ]
            }
          ]
        },
        {
          "type": "Milestone",
          "id": "P2.M2",
          "title": "Milestone 2.2: Export Committed Files",
          "status": "Planned",
          "description": "Extend the export command to support exporting files that were committed to layers (not just files currently in staging). This uses JinMap for fast lookups of layer contents.",
          "tasks": [
            {
              "type": "Task",
              "id": "P2.M2.T1",
              "title": "Query JinMap for Layer Contents",
              "status": "Planned",
              "description": "Modify export validation to check both staging index and committed layer contents via JinMap. This allows exporting files without re-staging them.",
              "subtasks": [
                {
                  "type": "Subtask",
                  "id": "P2.M2.T1.S1",
                  "title": "Load JinMap for layer lookups",
                  "status": "Planned",
                  "story_points": 1,
                  "dependencies": [],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: JinMap at .jin/.jinmap has layer contents (plan/architecture/codebase_analysis.md Section 6). Current export.rs only checks staging.\n2. INPUT: ExportArgs with file paths.\n3. LOGIC: In export::execute(), after loading JinRepo, load JinMap via repo.load_jinmap()?. JinMap provides fast lookup of which files are in which layers without walking Git trees.\n4. OUTPUT: Loaded JinMap instance for querying layer contents."
                },
                {
                  "type": "Subtask",
                  "id": "P2.M2.T1.S2",
                  "title": "Check file in committed layer contents",
                  "status": "Planned",
                  "story_points": 1,
                  "dependencies": [
                    "P2.M2.T1.S1"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: Current validate_jin_tracked only checks staging (plan/architecture/codebase_analysis.md Section 2, Gap #5).\n2. INPUT: File path from ExportArgs, JinMap from S1.\n3. LOGIC: Modify validate_jin_tracked() to also check JinMap if file not in staging. Use jinmap.find_layers_with_file(path) to get list of layers containing this file. If file is in any layer (staging or committed), validation passes. If in neither, return Err.\n4. OUTPUT: Enhanced validation that accepts committed files."
                },
                {
                  "type": "Subtask",
                  "id": "P2.M2.T1.S3",
                  "title": "Extract committed file content from layer",
                  "status": "Planned",
                  "story_points": 2,
                  "dependencies": [
                    "P2.M2.T1.S2"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: Need to read file from layer Git tree (plan/architecture/codebase_analysis.md Section 6.2).\n2. INPUT: File path, layer ref from JinMap.\n3. LOGIC: When exporting committed file, use repo.read_file_from_layer(path, layer_ref) to get file content from layer's Git tree. This uses git2 to read blob at specified path in layer's commit tree. Return content for export to Git.\n4. OUTPUT: File content from layer commit for export."
                }
              ]
            },
            {
              "type": "Task",
              "id": "P2.M2.T2",
              "title": "Add Integration Tests for Export Committed Files",
              "status": "Planned",
              "description": "Create integration tests for exporting committed files without re-staging. Tests must verify JinMap lookups and layer content extraction.",
              "subtasks": [
                {
                  "type": "Subtask",
                  "id": "P2.M2.T2.S1",
                  "title": "Test export committed file without staging",
                  "status": "Planned",
                  "story_points": 1,
                  "dependencies": [
                    "P2.M2.T1.S3"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: Use TestFixture with committed files (plan/architecture/test_analysis.md Section 1.1).\n2. INPUT: Layer with committed file, file not in staging.\n3. LOGIC: Create test that commits file to layer, clears staging index, then runs 'jin export <file>'. Verify export succeeds without staging. Assert file appears in project Git working directory.\n4. OUTPUT: Passing test for committed file export."
                },
                {
                  "type": "Subtask",
                  "id": "P2.M2.T2.S2",
                  "title": "Test export rejects untracked files",
                  "status": "Planned",
                  "story_points": 1,
                  "dependencies": [
                    "P2.M2.T2.S1"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: Validation must still reject untracked files (plan/architecture/test_analysis.md Section 5.2).\n2. INPUT: File not in Jin (not in staging or any layer).\n3. LOGIC: Create test that tries to export file never added to Jin. Verify command returns Err with 'file not tracked by Jin' message. Ensure file is not exported to project Git.\n4. OUTPUT: Passing test validating export validation."
                }
              ]
            }
          ]
        },
        {
          "type": "Milestone",
          "id": "P2.M3",
          "title": "Milestone 2.3: Active Context Notifications in Fetch",
          "status": "Planned",
          "description": "Enhance the fetch command to load ProjectContext and highlight updates affecting the active mode/scope. This improves user experience by calling attention to relevant updates.",
          "tasks": [
            {
              "type": "Task",
              "id": "P2.M3.T1",
              "title": "Load ProjectContext in Fetch Command",
              "status": "Planned",
              "description": "Modify the fetch command to load the active ProjectContext at the start. This provides the active mode/scope information for filtering updates.",
              "subtasks": [
                {
                  "type": "Subtask",
                  "id": "P2.M3.T1.S1",
                  "title": "Load active context at fetch start",
                  "status": "Planned",
                  "story_points": 1,
                  "dependencies": [],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: Current fetch.rs doesn't load context (plan/architecture/codebase_analysis.md Section 2, Gap #6). ProjectContext at .jin/context.\n2. INPUT: Fetch execute() function.\n3. LOGIC: At start of fetch::execute(), call ProjectContext::load()? to get active mode/scope. Handle case where context doesn't exist (use None). Store context for later comparison with updated refs.\n4. OUTPUT: Loaded ProjectContext with active mode/scope for filtering."
                }
              ]
            },
            {
              "type": "Task",
              "id": "P2.M3.T2",
              "title": "Filter and Highlight Active Context Updates",
              "status": "Planned",
              "description": "After fetching, compare updated refs against active mode/scope and display prominent notifications for relevant updates.",
              "subtasks": [
                {
                  "type": "Subtask",
                  "id": "P2.M3.T2.S1",
                  "title": "Compare updated refs with active context",
                  "status": "Planned",
                  "story_points": 1,
                  "dependencies": [
                    "P2.M3.T1.S1"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: Need to match refs to active mode/scope (plan/architecture/codebase_analysis.md Section 2, Gap #6).\n2. INPUT: List of updated refs from fetch, ProjectContext with active mode/scope.\n3. LOGIC: After fetching refs, iterate through updated_refs list. For each ref, extract layer type (mode/scope/project) and name. Compare against active mode/scope from context. Separate refs into two lists: active_updates (matching context) and other_updates (not matching).\n4. OUTPUT: Two lists of refs: active_updates and other_updates."
                },
                {
                  "type": "Subtask",
                  "id": "P2.M3.T2.S2",
                  "title": "Display prominent notification for active updates",
                  "status": "Planned",
                  "story_points": 1,
                  "dependencies": [
                    "P2.M3.T2.S1"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: PRD specifies format with warning emoji (plan/architecture/codebase_analysis.md Section 2, Gap #6).\n2. INPUT: active_updates list from S1.\n3. LOGIC: If active_updates not empty, display prominent section: '  Updates available for your active context:'. For each ref, show '- {ref_name} (active)'. Add 'Run \"jin pull\" to update.' instruction. Use distinct visual formatting (emoji, indentation).\n4. OUTPUT: User notification highlighting relevant updates."
                },
                {
                  "type": "Subtask",
                  "id": "P2.M3.T2.S3",
                  "title": "Display other updates in less prominent section",
                  "status": "Planned",
                  "story_points": 1,
                  "dependencies": [
                    "P2.M3.T2.S2"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: Other updates should be shown separately (plan/architecture/codebase_analysis.md Section 2, Gap #6).\n2. INPUT: other_updates list from S1.\n3. LOGIC: If other_updates not empty, display separate section: 'Other updates:' (without emoji). For each ref, show '- {ref_name} ({file_count} file(s))'. Keep this section visually distinct from active updates.\n4. OUTPUT: Complete fetch output with both sections."
                }
              ]
            },
            {
              "type": "Task",
              "id": "P2.M3.T3",
              "title": "Add Integration Tests for Active Context Notifications",
              "status": "Planned",
              "description": "Create integration tests for fetch command verifying active context updates are highlighted and other updates are shown separately.",
              "subtasks": [
                {
                  "type": "Subtask",
                  "id": "P2.M3.T3.S1",
                  "title": "Test fetch highlights active mode updates",
                  "status": "Planned",
                  "story_points": 1,
                  "dependencies": [
                    "P2.M3.T2.S3"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: Use TestFixture with remote and context (plan/architecture/test_analysis.md Section 1.1).\n2. INPUT: Active context with mode=claude, remote has update to mode/claude.\n3. LOGIC: Create test that sets active mode to 'claude', then runs 'jin fetch'. Verify output includes '  Updates available for your active context:' section with 'mode/claude (active)'. Parse output to confirm format.\n4. OUTPUT: Passing test for active update notification."
                },
                {
                  "type": "Subtask",
                  "id": "P2.M3.T3.S2",
                  "title": "Test fetch separates active and other updates",
                  "status": "Planned",
                  "story_points": 1,
                  "dependencies": [
                    "P2.M3.T3.S1"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: Test with multiple updates (plan/architecture/test_analysis.md Section 5.2).\n2. INPUT: Active mode=claude, remote has updates to mode/claude and scope/python.\n3. LOGIC: Create test with two remote updates, one matching active context, one not. Run 'jin fetch' and verify both sections appear: active updates with emoji, other updates without. Assert scope/python appears in 'Other updates' section.\n4. OUTPUT: Passing test for separation of updates."
                }
              ]
            }
          ]
        },
        {
          "type": "Milestone",
          "id": "P2.M4",
          "title": "Milestone 2.4: Fix Failing Unit Tests",
          "status": "Planned",
          "description": "Fix the 12 failing unit tests to achieve 100% test reliability. Issues include test isolation problems, Git lock contention, and test expectation mismatches.",
          "tasks": [
            {
              "type": "Task",
              "id": "P2.M4.T1",
              "title": "Fix Test Infrastructure Issues",
              "status": "Planned",
              "description": "Improve test infrastructure to fix common failure patterns. This includes unifying test setup, adding pre-test cleanup, and using absolute paths consistently.",
              "subtasks": [
                {
                  "type": "Subtask",
                  "id": "P2.M4.T1.S1",
                  "title": "Create common test setup module",
                  "status": "Planned",
                  "story_points": 2,
                  "dependencies": [],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: Multiple setup_test_env() functions duplicated (plan/architecture/test_analysis.md Section 4.2). Use absolute paths instead of set_current_dir (Section 5.1).\n2. INPUT: Existing setup_test_env() patterns from various command test modules.\n3. LOGIC: Create tests/common/unit_setup.rs with unified setup_unit_test() function. Use absolute paths from TempDir instead of set_current_dir(). Set JIN_DIR to absolute path. Initialize JinRepo and create .jin directory structure. Return UnitTestContext with tempdir, repo, and paths.\n4. OUTPUT: Common test setup module for all unit tests."
                },
                {
                  "type": "Subtask",
                  "id": "P2.M4.T1.S2",
                  "title": "Add pre-test Git lock cleanup",
                  "status": "Planned",
                  "story_points": 1,
                  "dependencies": [
                    "P2.M4.T1.S1"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: Git locks leak between tests (plan/architecture/test_analysis.md Section 3.2). Need cleanup before test runs.\n2. INPUT: Test setup function from S1.\n3. LOGIC: In setup_unit_test(), before creating new temp directory, check if JIN_DIR env var is set. If yes, attempt to clean up any stale .git/index.lock or .git/config.lock files in previous JIN_DIR. Use std::fs::remove_file() with error suppression (file may not exist).\n4. OUTPUT: Pre-test cleanup reducing lock contention."
                },
                {
                  "type": "Subtask",
                  "id": "P2.M4.T1.S3",
                  "title": "Update all unit tests to use common setup",
                  "status": "Planned",
                  "story_points": 2,
                  "dependencies": [
                    "P2.M4.T1.S2"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: 6+ tests have file system issues from bad setup (plan/architecture/test_analysis.md Section 2.2-2.7).\n2. INPUT: List of test modules with local setup_test_env() functions.\n3. LOGIC: Replace local setup_test_env() in src/commands/{mode.rs,diff.rs,mv.rs,repair.rs,reset.rs,rm.rs} with common tests::common::unit_setup::setup_unit_test(). Update all test functions to use UnitTestContext instead of local TempDir.\n4. OUTPUT: All tests using unified setup infrastructure."
                }
              ]
            },
            {
              "type": "Task",
              "id": "P2.M4.T2",
              "title": "Fix File System Path Issues",
              "status": "Planned",
              "description": "Fix 6 tests failing due to file not found errors. Tests need proper directory creation and absolute path usage.",
              "subtasks": [
                {
                  "type": "Subtask",
                  "id": "P2.M4.T2.S1",
                  "title": "Fix diff test_execute_staged_empty",
                  "status": "Planned",
                  "story_points": 1,
                  "dependencies": [
                    "P2.M4.T1.S3"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: Missing staging index file (plan/architecture/test_analysis.md Section 2.2).\n2. INPUT: Test using setup_unit_test().\n3. LOGIC: After test setup, explicitly create .jin/staging/index.json with empty staging index: 'touch .jin/staging/index.json' and write '{}'. Then run diff command. Update test assertions to check for Ok(()) result.\n4. OUTPUT: Passing test for empty staging diff."
                },
                {
                  "type": "Subtask",
                  "id": "P2.M4.T2.S2",
                  "title": "Fix mv tests with file creation",
                  "status": "Planned",
                  "story_points": 1,
                  "dependencies": [
                    "P2.M4.T1.S3"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: Tests don't create required files (plan/architecture/test_analysis.md Section 2.4).\n2. INPUT: mv test functions using setup_unit_test().\n3. LOGIC: Before testing mv command, use UnitTestContext.path to create test files with std::fs::write(). Ensure parent directories exist with create_dir_all(). Use absolute paths from context, not relative paths.\n4. OUTPUT: mv tests finding required files."
                },
                {
                  "type": "Subtask",
                  "id": "P2.M4.T2.S3",
                  "title": "Fix reset test with layer ref creation",
                  "status": "Planned",
                  "story_points": 1,
                  "dependencies": [
                    "P2.M4.T1.S3"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: reset test expects ref that doesn't exist (plan/architecture/test_analysis.md Section 2.6).\n2. INPUT: reset test function.\n3. LOGIC: Before testing reset, create a layer ref with some content using JinRepo. Commit a file to mode/test-layer, then use that ref in reset command. Update test assertions to verify reset worked correctly.\n4. OUTPUT: reset test with valid layer ref."
                },
                {
                  "type": "Subtask",
                  "id": "P2.M4.T2.S4",
                  "title": "Fix rm test with staging setup",
                  "status": "Planned",
                  "story_points": 1,
                  "dependencies": [
                    "P2.M4.T1.S3"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: rm test expects staging state (plan/architecture/test_analysis.md Section 2.7).\n2. INPUT: rm test function.\n3. LOGIC: Before testing rm dry-run, stage a file using add command or direct staging index manipulation. Verify file is staged before running rm. Update assertions to check staging state changes.\n4. OUTPUT: rm test with proper staging setup."
                }
              ]
            },
            {
              "type": "Task",
              "id": "P2.M4.T3",
              "title": "Fix Git Lock Contention Issues",
              "status": "Planned",
              "description": "Fix 4 mode command tests failing due to Git lock contention. Pre-test cleanup and better isolation should resolve these.",
              "subtasks": [
                {
                  "type": "Subtask",
                  "id": "P2.M4.T3.S1",
                  "title": "Fix mode command tests",
                  "status": "Planned",
                  "story_points": 1,
                  "dependencies": [
                    "P2.M4.T1.S2"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: Mode tests have Git lock issues (plan/architecture/test_analysis.md Section 2.1).\n2. INPUT: mode tests using setup_unit_test().\n3. LOGIC: Ensure all mode tests use #[serial] attribute to prevent parallel execution. After switching to common setup, pre-test cleanup from T1.S2 should prevent lock leakage. Verify ref paths in assertions match actual implementation.\n4. OUTPUT: Mode tests passing without lock errors."
                }
              ]
            },
            {
              "type": "Task",
              "id": "P2.M4.T4",
              "title": "Fix Test Expectation Mismatches",
              "status": "Planned",
              "description": "Fix 2 repair command tests where expectations don't match implementation behavior. Update tests to match actual implementation or fix implementation if behavior is wrong.",
              "subtasks": [
                {
                  "type": "Subtask",
                  "id": "P2.M4.T4.S1",
                  "title": "Fix test_check_staging_index_corrupted",
                  "status": "Planned",
                  "story_points": 1,
                  "dependencies": [],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: Test expects 1 issue, gets 0 (plan/architecture/test_analysis.md Section 2.5).\n2. INPUT: Test code with corrupted staging index.\n3. LOGIC: Run the test and capture actual behavior. If check_staging_index() doesn't detect corruption, fix implementation to return issue for JSON parse errors. If implementation is correct (no issue), update test expectation to match actual behavior.\n4. OUTPUT: Test passing with correct expectations."
                },
                {
                  "type": "Subtask",
                  "id": "P2.M4.T4.S2",
                  "title": "Fix test_create_default_context",
                  "status": "Planned",
                  "story_points": 1,
                  "dependencies": [],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: Context file not created (plan/architecture/test_analysis.md Section 2.5).\n2. INPUT: Test code expecting context creation.\n3. LOGIC: Run test and check if repair --create-context actually creates .jin/context file. If not, check if this is expected behavior (maybe context creation is separate command). Update test assertions to match actual behavior.\n4. OUTPUT: Test aligned with implementation behavior."
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "type": "Phase",
      "id": "P3",
      "title": "Phase 3: Polish and Documentation",
      "status": "Planned",
      "description": "Address low-priority gaps including staging index TODOs, JIN_DIR documentation, and any remaining polish items to complete 100% PRD compliance.",
      "milestones": [
        {
          "type": "Milestone",
          "id": "P3.M1",
          "title": "Milestone 3.1: Staging Index Optimization",
          "status": "Planned",
          "description": "Evaluate staging index TODO comments and implement any required optimizations or validation. Current basic functionality works, but TODOs suggest improvements may be needed.",
          "tasks": [
            {
              "type": "Task",
              "id": "P3.M1.T1",
              "title": "Evaluate Staging Index TODOs",
              "status": "Planned",
              "description": "Investigate the TODO comments in src/staging/index.rs to determine if 'proper loading' and 'proper saving' require implementation changes.",
              "subtasks": [
                {
                  "type": "Subtask",
                  "id": "P3.M1.T1.S1",
                  "title": "Analyze current load/save implementation",
                  "status": "Planned",
                  "story_points": 1,
                  "dependencies": [],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: TODOs at lines 34 and 50 (plan/architecture/codebase_analysis.md Section 2, Gap #7).\n2. INPUT: src/staging/index.rs with TODO comments.\n3. LOGIC: Review current load() and save() implementations. Identify what 'proper' means: validation? atomic writes? error handling? performance? Document current behavior vs desired behavior. Check if tests pass with current implementation.\n4. OUTPUT: Analysis document describing current state and required improvements."
                },
                {
                  "type": "Subtask",
                  "id": "P3.M1.T1.S2",
                  "title": "Implement required improvements",
                  "status": "Planned",
                  "story_points": 2,
                  "dependencies": [
                    "P3.M1.T1.S1"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: Based on analysis from S1 (plan/architecture/codebase_analysis.md Section 2, Gap #7).\n2. INPUT: Analysis findings from S1.\n3. LOGIC: If improvements needed, implement: add validation for corrupted index data, use atomic writes (write to temp file then rename), add error recovery, or improve performance. If current implementation is adequate, update TODO comments to explain why 'proper' implementation exists.\n4. OUTPUT: Improved or documented load/save implementation."
                }
              ]
            }
          ]
        },
        {
          "type": "Milestone",
          "id": "P3.M2",
          "title": "Milestone 3.2: JIN_DIR Documentation",
          "status": "Planned",
          "description": "Document the JIN_DIR environment variable in user-facing documentation. Add config command to view/set Jin directory location.",
          "tasks": [
            {
              "type": "Task",
              "id": "P3.M2.T1",
              "title": "Document JIN_DIR in README",
              "status": "Planned",
              "description": "Add documentation to README.md explaining the JIN_DIR environment variable, its default location, and how to customize it.",
              "subtasks": [
                {
                  "type": "Subtask",
                  "id": "P3.M2.T1.S1",
                  "title": "Add JIN_DIR section to README",
                  "status": "Planned",
                  "story_points": 1,
                  "dependencies": [],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: PRD Section 19.1 mentions JIN_DIR (plan/architecture/codebase_analysis.md Section 2, Gap #8).\n2. INPUT: README.md file.\n3. LOGIC: Add 'Configuration' section to README with 'JIN_DIR Environment Variable' subsection. Explain: default location (~/.jin/), how to override (export JIN_DIR=/path/to/jin), use cases (multiple Jin repos, per-project Jin), and that tests use it for isolation. Add examples.\n4. OUTPUT: User-facing documentation for JIN_DIR."
                }
              ]
            },
            {
              "type": "Task",
              "id": "P3.M2.T2",
              "title": "Add Config Command",
              "status": "Planned",
              "description": "Implement a 'jin config' command to view and set Jin configuration options, including the Jin directory location.",
              "subtasks": [
                {
                  "type": "Subtask",
                  "id": "P3.M2.T2.S1",
                  "title": "Add config CLI arguments",
                  "status": "Planned",
                  "story_points": 1,
                  "dependencies": [],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: Follow clap derive pattern (plan/architecture/external_deps.md Section 1.6).\n2. INPUT: User command line input.\n3. LOGIC: Add ConfigArgs struct to src/cli/mod.rs with optional fields: 'get: Option<String>' for retrieving config values, 'set: Option<Vec<String>>' for setting key=value pairs. Add '--jin-dir <path>' flag for setting Jin directory. Derive Parser.\n4. OUTPUT: ConfigArgs struct for config command."
                },
                {
                  "type": "Subtask",
                  "id": "P3.M2.T2.S2",
                  "title": "Implement config get command",
                  "status": "Planned",
                  "story_points": 1,
                  "dependencies": [
                    "P3.M2.T2.S1"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: Simple key-value lookup (plan/architecture/codebase_analysis.md Section 8.3).\n2. INPUT: ConfigArgs.get field with config key.\n3. LOGIC: In config::execute(), if 'get' is Some(key), retrieve value from JinConfig or environment. For 'jin-dir', get from env::var('JIN_DIR') with default. Display value. If key not recognized, show available keys.\n4. OUTPUT: Config value displayed to user."
                },
                {
                  "type": "Subtask",
                  "id": "P3.M2.T2.S3",
                  "title": "Implement config set command",
                  "status": "Planned",
                  "story_points": 2,
                  "dependencies": [
                    "P3.M2.T2.S2"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: JIN_DIR is env var, not file config (plan/architecture/codebase_analysis.md Section 2, Gap #8).\n2. INPUT: ConfigArgs.set field with key=value pairs.\n3. LOGIC: In config::execute(), if 'set' is Some(pairs), parse each pair. For 'jin-dir' key, instruct user to set environment variable (Jin doesn't write to shell profile). For other config, write to .jin/config.json. Show success message.\n4. OUTPUT: Configuration set or user instructed."
                }
              ]
            }
          ]
        }
      ]
    }
  ]
}